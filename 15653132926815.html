<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	计算机二级 公共知识 - 程序猿CubeTian
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="程序猿CubeTian" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
					
					<h1><a href="index.html">程序猿CubeTian</a></h1>
					<p class="subtitle">众所周知，数学研究只需要一支笔和一堆草稿纸</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">













								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">

	<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
		<h1 class="title" itemprop="name">计算机二级 公共知识</h1>
		<div class="entry-content" itemprop="articleBody">
			<h2 id="toc_0">程序设计基础</h2>

<ol>
<li>程序设计的方法和风格：“清晰第一、效率第二”
<ol>
<li>源程序文档化
<ol>
<li>符号名的命名：</li>
<li>程序注释：</li>
<li>视觉组织：</li>
</ol></li>
<li>数据说明方法
<ol>
<li>数据说明次序规范化</li>
<li>说明语句中变量安排有序化</li>
<li>使用注释来说明复杂的数据结构</li>
</ol></li>
<li>语句的结构</li>
<li>输入和输出</li>
</ol></li>
<li>结构化程序设计
<ol>
<li>原则：自顶向下、逐步求精、模块化、限制使用goto语句</li>
</ol></li>
<li>结构化程序的基本结构与特点
<ol>
<li>顺序结构</li>
<li>选择结构</li>
<li>循环结构</li>
</ol></li>
<li>结构化程序设计原则和方法的应用</li>
<li>面向对象的程序设计
<ol>
<li>面向对象方法的优点
<ol>
<li>与人类习惯的思维方法一致</li>
<li>稳定性好</li>
<li>可重用性好</li>
<li>易于开发大型软件产品</li>
<li>可维护性好</li>
</ol></li>
<li>基本概念
<ol>
<li>对象：应用领域中有意义的，与所要解决问题有关的任何事物都可以作为对象，它既可以是具体的物理实体的抽象，也可以是人为的概念，或者是任何有明确边界和意义的东西。由一组表示其静态性质的属性和它可执行的一组操作组成
<ol>
<li>标识唯一性：由对象的内在本质区分，而不是通过表述来区分</li>
<li>分类性</li>
<li>多态性</li>
<li>封装性</li>
</ol></li>
<li>类和实例：类是具有共同属性共同方法的对象的集合。当使用对象这个词时，既可以指具体对象，也可以指一般对象，但是实例必然是一个具体对象。</li>
<li>消息：消息是一个实例与另一个实例之间传递的信息，它请求对象执行某一处理或回答某一要求的信息，它统一了数据流和控制流，组成：
<ol>
<li>接收消息的对象名称</li>
<li>消息标识符（消息名）</li>
<li>零个或多个参数</li>
</ol></li>
<li>继承：是使用已有的类定义作为基础建立新类的定义技术
<ol>
<li>单继承：一个类只允许有一个父类</li>
<li>多继承：一个类允许有多个父类，功能更强，使用方便，但是要避免二义性</li>
</ol></li>
<li>多态性：对象根据所接受的信息做出动作，同样的消息被不同的对象接收时可导致完全不同的行动。在面对对象的软件技术中，多态性是指子类对象可以像父类对象那样使用，同样的消息既可以发送给父类对象，又可以发送给子类对象</li>
</ol></li>
</ol></li>
</ol>

<h2 id="toc_1">数据库知识基础</h2>

<ol>
<li>数据库系统的基本概念
<ol>
<li>数据（DATA）：描述事物的符号记录
<ol>
<li>数据分为临时性、持久性</li>
<li>数据有 型 、值 之分</li>
<li>将多种相关数据以一定的结构方式组合构成特定的数据框架，这样的数据框架称为数据结构，数据库在特定的条件下称为数据模式</li>
</ol></li>
<li>数据库（DATABASE，DB）：数据的集合，它具有统一的结构形式并存放于统一的存储介质内，是多种应用数据的集成，并可被各个应用程序所共享</li>
<li>数据库管理系统（Database Managerment System DBMS）：是数据库的机构，它是一种系统软件，负责数据库中的数据组织，数据操控，数据维护、控制及保护和数据服务<br/>
    功能：
<ol>
<li>数据模式定义</li>
<li>数据存取的物理构建</li>
<li>数据操纵</li>
<li>数据的完整性、安全性定义与检查：数据的完整性与安全性的维护是数据库管理系统的基本功能</li>
<li>数据库的并发控制与故障恢复</li>
<li>数据的服务：数据的拷贝、转存、重组、性能检测、分析<br/>
数据语言：</li>
<li>数据定义语言（DDL）：负责数据的模式定义与数据的物理存储构建</li>
<li>数据操作语言（DML）：负责数据的操作，查增删改</li>
<li>数据控制语言（DCL）：负责数据完整性、安全性的定义与检查以及并发控制、故障恢复等功能</li>
</ol></li>
<li>数据库管理员（DBA）：
<ol>
<li>数据库设计（Database Design）</li>
<li>数据库维护</li>
<li>改善系统性能，提高系统效率</li>
</ol></li>
<li>数据库系统（DBS）
<ol>
<li>数据库（数据）</li>
<li>数据库管理系统软件（软件）</li>
<li>数据库管理员（人员）</li>
<li>系统平台之一——硬件平台（硬件）：计算机、网络</li>
<li>系统平台之二——软件平台（软件）：操作系统、数据库系统开发工具</li>
</ol></li>
<li>数据库应用系统（DBAS）：数据库系统+应用软件+应用界面
<ol>
<li>数据库</li>
<li>数据库管理系统</li>
<li>数据库管理员</li>
<li>硬件平台</li>
<li>软件平台</li>
<li>应用软件</li>
<li>应用界面</li>
</ol></li>
</ol></li>
<li>数据库发展
<ol>
<li>文件系统阶段</li>
<li>层次数据库与网状数据库系统阶段</li>
<li>关系数据库系统阶段</li>
<li>未来：
<ol>
<li>面向对象数据库系统</li>
<li>知识库系统</li>
<li>关系数据库系统的扩充</li>
</ol></li>
</ol></li>
<li>数据库系统的基本特点
<ol>
<li>数据的集成性：
<ol>
<li>统一的数据结构方式</li>
<li>按照多个应用的需要组织全局的统一的数据结构</li>
<li>数据模式是多个应用共同的、全局的数据结构</li>
</ol></li>
<li>数据的高共享性与低冗余性</li>
<li>数据的独立性
<ol>
<li>物理独立性：数据库的物理结构改变不影响逻辑结构</li>
<li>逻辑独立性：数据库总体逻辑改变不影响相应的应用程序</li>
</ol></li>
<li>数据的统一管理与控制
<ol>
<li>数据的完整性检查</li>
<li>数据的安全性保护</li>
<li>并发控制</li>
</ol></li>
</ol></li>
<li>数据库系统的内部结构体系：数据库在其内部有三级模式及二级映射
<ol>
<li>三级模式
<ol>
<li>概念模式：数据库系统中全局数据逻辑结构的描述，是全体用户公用数据视图</li>
<li>外模式（子模式、用户模式）：用户的数据视图</li>
<li>内模式（物理模式）：数据物理存储结构与物理存取方法</li>
</ol></li>
<li>二级映射
<ol>
<li>概念模式到内模式的映射</li>
<li>外模式到概念模式到映射</li>
</ol></li>
</ol></li>
<li>数据模型：数据库中的数据模型可以将复杂的现实世界要求反映到计算机数据库中的物理世界，这种反映是一个逐步变化的过程：由现实世界开始，经历信息世界而至计算机世界
<ol>
<li>世界
<ol>
<li>现实世界（Real World）</li>
<li>信息世界（Information World）:通过抽象对现实世界进行数据库级上的刻画所构成的逻辑模型叫信息世界，信息世界与数据库的具体模型有关</li>
<li>计算机世界（Computer World）：在信息世界的基础上致力于其在计算机物理结构上的描述，而形成的逻辑模型叫计算机世界</li>
</ol></li>
<li>数据模型：数据模型所描述的内容有三个部分：数据结构、数据操作、数据约束
<ol>
<li>数据结构：主要描述数据的类型、内容、性质以及数据间的联系</li>
<li>数据操纵：</li>
<li>数据约束：描述数据结构内数据间的语法、语义联系，它们之间的制约与依存关系，以及数据间的动态变化规则</li>
</ol></li>
<li>分类：
<ol>
<li>概念数据模型：是一种面向客观世界、面向用户的模型。概念数据模型是整个数据模型的基础，如E-R模型、扩充的E-R模型、面向对象模型以及谓词模型</li>
<li>逻辑数据模型：是一种面向数据库系统的模型。如，层次模型、网状模型、关系模型、面向对象模型</li>
<li>物理数据模型：面向计算机物理表示的模型</li>
</ol></li>
</ol></li>
<li>E-R模型（实体联系模型）
<ol>
<li>基本概念：
<ol>
<li>实体：现实世界中的事物可以抽象成为实体，实体是概念世界中的基本单位，它们是客观存在又相互区别的事物</li>
<li>属性：现实世界中的事物均有一些特点，这些特性可以用属性来表示</li>
<li>联系：现实世界中事物之间的关联称为联系
<ol>
<li>实体集间的联系
<ol>
<li>两个实体集之间的联系</li>
<li>多个实体集之间的联系</li>
<li>一个实体集内部的联系</li>
</ol></li>
<li>联系的个数
<ol>
<li>一对一的联系，简记为1:1</li>
<li>一对多的联系，简记为1:m或m：1</li>
<li>多对多的联系，简记为m:n</li>
</ol></li>
</ol></li>
<li>三个基本概念之间的联系
<ol>
<li>实体集（联系）与属性之间的连接关系
<ol>
<li>一个实体的所有属性取值组成一个值集叫元组（Tuple）</li>
<li>联系也可以附有属性</li>
</ol></li>
<li>实体（集）与联系
<ol>
<li>实体集之间可以通过联系建立连接关系，实体集之间无法建立直接关系，它只能通过联系才能建立连接关系</li>
</ol></li>
</ol></li>
<li>E-R模型的图示法：
<ol>
<li>实体集：矩形表示实体集，在矩形内部写上该实体集的名字</li>
<li>属性：用椭圆表示属性，在椭圆内部写上该属性的名称</li>
<li>联系表示法：用菱形表示联系，内写上联系名</li>
<li>实体集（联系）与属性之间连接关系：用连接两个图形之间的无向线段表示</li>
<li>实体集与联系间的连接关系：用连接两个图形的无向线段表示，还可以注明对应的函数关系</li>
</ol></li>
</ol></li>
</ol></li>
<li>层次模型：
<ol>
<li>基本结构：树形结构</li>
<li>特点：
<ol>
<li>每棵树有且只有一个无双亲结点，称为根（Root）</li>
<li>树中除根以外所有结点有且只有一个双亲</li>
</ol></li>
<li>缺点：
<ol>
<li>如果没有相应的双亲结点值就不能插入子女结点值</li>
<li>如果删除双亲结点值，则相应的子女结点值也被同时删除</li>
<li>查询子女结点必须通过双亲结点</li>
</ol></li>
</ol></li>
<li>网状模型：网状模型是一个不加任何限制的无向图
<ol>
<li>网状模型将通用的网状拓扑结构分成一些基本结构。一般采用的分解方法是将一个网络分成若干个二级树</li>
<li>基本结构简单二级树叫系（Set），系的基本单位是记录（Record），系有一个首记录（Owner Record），它相当于简单二级树的根，系同时有若干个成员记录（Member Record）</li>
</ol></li>
<li>关系模型
<ol>
<li>关系的数据结构：关系模式采用二维表来表示，简称表。二维表由表框架（Frame）及表的元组（Tuple）组成。<br/>
二维表满足以下性质：满足以下性质的二维表称为关系（Relation）
<ol>
<li>元组个数有限性</li>
<li>元组唯一性</li>
<li>元组的次数无关性</li>
<li>元组分量的原子性</li>
<li>属性名唯一性</li>
<li>属性的次序无关性</li>
<li>分量的值域的同一性</li>
</ol></li>
<li>关系操作
<ol>
<li>数据查询：分解为一个关系内的属性指定、一个关系内的元组选择、两个关系的合并三个基本操作以及一个查询操作</li>
<li>数据删除：一个关系内的元组选择与关系中元组删除两个基本操作</li>
<li>数据插入：只有一个基本操作</li>
<li>数据修改：不是基本操作，可分解为删除需修改的元组与插入修改后的元组两个更基本操作</li>
</ol></li>
<li>关系中的数据约束
<ol>
<li>实体完整性约束</li>
<li>参照完整性约束：不允许关系引用不存在的元组：即在关系中的外键要么是所关联关系中实际存在的元组，要么就为空值</li>
<li>用户定义的完整性约束</li>
</ol></li>
</ol></li>
<li>关系代数
<ol>
<li>关系模型的基本操作：
<ol>
<li>关系的属性指定</li>
<li>关系的元组的选择</li>
<li>两个关系的合并</li>
<li>关系的查询</li>
<li>关系元组的插入</li>
<li>关系元组的删除</li>
</ol></li>
<li>关系模型的基本运算
<ol>
<li>插入</li>
<li>删除</li>
<li>修改：删除+插入</li>
<li>查询：
<ol>
<li>投影运算：投影出一个列（属性集合）</li>
<li>选择运算：选择元组</li>
<li>笛卡尔积运算：两个关系的合并操作</li>
</ol></li>
</ol></li>
<li>关系代数中的扩充运算
<ol>
<li>交运算：</li>
<li>除运算：笛卡尔积的逆运算</li>
<li>连接与自然连接运算</li>
</ol></li>
<li>关系代数的应用实例</li>
</ol></li>
<li>数据库设计与管理
<ol>
<li>数据库设计概念：</li>
<li>设计方法
<ol>
<li>面向数据的方法：以信息需求为主兼顾处理需求（主流）</li>
<li>面向过程的方法：以处理需求为主，兼顾信息需求</li>
</ol></li>
<li>生命周期法：将整个数据库应用系统的开发分解成目标独立的若干阶段，需求分析阶段、概念设计阶段、逻辑设计阶段、物理设计阶段、编码阶段、测试阶段、运行阶段、进一步修改阶段。数据库设计中采用前四个阶段</li>
<li>需求分析
<ol>
<li>获取用户的如下要求：
<ol>
<li>信息要求</li>
<li>处理要求</li>
<li>安全性和完整性要求</li>
</ol></li>
<li>数据字典是进行详细的数据收集和数据分析所获的的主要结果</li>
</ol></li>
<li>数据库概念设计
<ol>
<li>概述
<ol>
<li>集中式模型设计法</li>
<li>视图集成模式设计法</li>
</ol></li>
<li>过程
<ol>
<li>选择局部应用</li>
<li>视图设计
<ol>
<li>自顶向下</li>
<li>自底向上</li>
<li>由内向外</li>
</ol></li>
<li>视图集成
<ol>
<li>注意：命名冲突、概念冲突、域冲突、约束冲突</li>
</ol></li>
</ol></li>
</ol></li>
<li>数据库的逻辑设计
<ol>
<li>从E-R图向关系模式转换
<ol>
<li>实体集与联系都可以表示成关系</li>
<li>属性转换为关系的属性</li>
<li>实体转换为元组</li>
</ol></li>
<li>逻辑模式规范化及调整、实现
<ol>
<li>规范化：设计不良的关系模式会有数据冗余、插入异常、删除异常及修改异常等问题，需要通过分解进行规范化
<ol>
<li>对于关系模式若其中的每个属性都已不能再分为简单项，则它属于第一范式模式（1NF）</li>
<li>如果某个关系模式R为第一范式并且R中每一个非主属性完全函数依赖于R的某个候选键，则称其为第二范式模式（2NF）（消除了非主属性对主键的部分依赖）</li>
<li>如果关系模式R是第二范式，并且每个非主属性都不传递依赖于R的候选键，则称R为第三范式模式（3NF）</li>
<li>更高级的是BCNF，要求所有属性都不传递依赖于关系的任何候选键，但是并不一定要做到，一般做到三就好了</li>
</ol></li>
<li>RDBMS
<ol>
<li>调整性能以减少连接运算</li>
<li>调整关系大小，使每个关系数量保持在合理水平，从而提高存取效率</li>
<li>尽量采用快照</li>
</ol></li>
</ol></li>
<li>关系视图设计：关系视图是在关系模式基础上所设计的直接面向操作用户的视图，它可以根据用户需求随时创建
<ol>
<li>提供数据逻辑独立性</li>
<li>能适应用户对数据的不同需求</li>
<li>有一定数据保密功能</li>
</ol></li>
</ol></li>
<li>数据库的物理设计
<ol>
<li>数据库管理
<ol>
<li>数据库建立
<ol>
<li>数据模式建立</li>
<li>数据加载</li>
</ol></li>
</ol></li>
<li>数据库的调整</li>
<li>数据库的重组</li>
<li>数据库安全性控制与完整性控制</li>
<li>数据库的故障较复</li>
<li>数据库监控</li>
</ol></li>
</ol></li>
</ol>

<h2 id="toc_2">数据结构与算法</h2>

<ol>
<li>算法基本特征：
<ol>
<li>可行性：每个步骤能够实现；结果能达到预期</li>
<li>确定性</li>
<li>有穷性</li>
<li>拥有足够多的情报</li>
</ol></li>
<li>算法设计基本方法
<ol>
<li>列举法</li>
<li>归纳法</li>
<li>递推</li>
<li>递归
<ol>
<li>自己调用自己的过程称为递归调用过程</li>
</ol></li>
<li>减半递推技术
<ol>
<li>二分法求方程实根</li>
</ol></li>
<li>回溯法</li>
</ol></li>
<li>算法的复杂程度
<ol>
<li>算法时间复杂度：算法的工作量与算法所执行的基本运算次数以及问题的规模有关，而有时算法所执行的基本运算次数与特定的输入有关
<ol>
<li>平均性态：各种特定输入下基本运算次数的加权平均数。A(n)</li>
<li>最坏情况复杂性：在规模为n时，算法所执行的基本运算的最大次数。W(n)。比A(n)更具有实用价值。</li>
</ol></li>
<li>算法的空间复杂度：执行这个算法所需要的内存空间</li>
</ol></li>
<li>数据结构
<ol>
<li>数据结构是指反应数据元素之间关系的数据元素集合的表示</li>
<li>数据处理：是指对数据集合中的各元素以各种方式进行运算，包括插入、删除、查找、更改等，也包括对数据元素进行分析</li>
<li>前后件关系时数据元素之间的一个基本关系，数据元素之间的任何关系都可以用前后件关系来描述</li>
</ol></li>
<li>数据的逻辑结构:
<ol>
<li>一个数据结构应该包括：
<ol>
<li>表示数据元素的信息</li>
<li>表示各元素之间的前后件关系，其中，数据元素之间的前后件关系是指它们的逻辑关系，与它们在计算机中的储存位置无关</li>
</ol></li>
<li>B=(D,R) data,relation</li>
</ol></li>
<li>数据的储存结构
<ol>
<li>数据的逻辑结构在计算机储存空间中的存放形式称为数据的储存结构</li>
<li>常用的储存结构：顺序、链接、索引</li>
</ol></li>
<li>线性结构与非线性结构
<ol>
<li>如果在一个数据结构中一个元素都没有，则称该数据结构为空的数据结构</li>
<li>线性结构（线性表）：
<ol>
<li>有且只有一个根节点</li>
<li>每一个结点最多有一个前件，也最多有一个后件</li>
<li>在一个线性结构中插入或删除任何一个结点后还应是线性结构</li>
</ol></li>
<li>非线性结构：不是线性就是非线性</li>
<li>一个空的数据结构是线性还是非线性根据具体情况确定，如果对该数据结构的运算是按线性结构规则处理的则属于线性结构，否则属于非线性结构。</li>
</ol></li>
<li>线性表及其顺序储存结构
<ol>
<li>线性表是由n个数据元素组成的一个有限序列，表中的每一个元素，除了第一个以外，有且只有一个前件，除了最后一个外，有且只有一个后件</li>
<li>矩阵也是一个线性表</li>
<li>复杂的线性表中，由若干数据项组成的数据元素称为记录，由多个记录构成的线性表又称为文件</li>
<li>线性表的顺序储存结构：
<ol>
<li>线性表中所有元素所占的储存空间是连续的</li>
<li>线性表中个数据元素在储存空间中是按逻辑顺序依次存放的</li>
</ol></li>
<li>顺序表的插入运算：效率低，可能发生“上溢”错误</li>
<li>顺序表的删除运算：效率低，可能发生“下溢”错误</li>
</ol></li>
<li>栈和队列
<ol>
<li>栈：限定在一端进行插入和删除的线性表
<ol>
<li>在顺序储存结构下，对栈的插入与删除时不需要移动表中其他元素的</li>
<li>允许插入与删除的一端称为栈顶，不允许插入和删除的一端称为栈底</li>
<li>先进后出，后进先出（FILO，LIFO），栈具有记忆功能</li>
<li>通常用指针top来指示栈顶的位置，用指针bottom指向栈底</li>
<li>在栈中插入一个元素称为入栈运算，删除一个元素称为退栈运算</li>
<li>栈的顺序储存及运算
<ol>
<li>入栈运算</li>
<li>退栈运算</li>
<li>读栈顶元素</li>
</ol></li>
</ol></li>
<li>队列：指允许在一端进行插入，而在另外一端进行删除的线性表
<ol>
<li>允许插入的一端称为队尾，通常用一个尾指针（rear）指向队尾元素；允许删除的一端称为排头（队头），通常用排头指针（front）指向排头元素的前一个位置。</li>
<li>先进先出，后进后出（FIFO，LILO）</li>
<li>在队尾插入一个元素称为入队运算，从排头删除一个元素称为退队运算</li>
<li>循环队列：在实际应用中，队列的顺序储存结构一般采用循环队列的形式。Front=rear时，队列要么为空，要么为满，所以要加一个标志s，s=0为空，1为非空</li>
</ol></li>
</ol></li>
<li>线性链表
<ol>
<li>链式储存方式中，要求每个结点有由两部分组成：一部分用于存放数据元素值，称为数据域，另一部分用于存放指针，称为指针域。其中指针用于指向该结点的前一个或后一个结点</li>
<li>线性表的链式存储方式称为线性链表：指针域用于指向下一个元素的存储序号</li>
<li>双向链表：一个左指针（Llink）指向前件结点，一个右指针（Rlink）指向后件结点</li>
<li>带链的栈：</li>
<li>带栈的队列</li>
<li>循环链表：增加一个表头结点，最后一个结点的指针域不为空，而是指向表头结点
<ol>
<li>只要指出表中任意结点位置，就可以从它出发访问到表中其他所有的结点，线性单链表做不到</li>
<li>由于设置表头结点，因此，在任何情况下，循环链表中至少有一个结点，使空表与非空表运算统一</li>
</ol></li>
</ol></li>
<li>树与二叉树
<ol>
<li>树中，每一个结点只有一个前件，称为父结点，每一个节点可以有多个后件，称为子结点，没有后件的结点称为叶子结点。一个结点所拥有的后件个数称为该结点的度，在树中，所以结点中最大的度称为树的度；在树中，所以结点的度之和再加一为树的结点数。树的最大层数称为树的深度</li>
<li>二叉树基本性质
<ol>
<li>性质一</li>
<li>性质二</li>
<li>性质三：在任意一颗二叉树中，度为零的结点总是比度为2的结点多一个</li>
<li>性质四</li>
</ol></li>
<li>满二叉树：每一层上的结点数都达到最大值</li>
<li>完全二叉树：除最后一层外，每一层上的结点数均达到最大值，在最后一层上只缺少右边的若干结点。
<ol>
<li>性质五</li>
<li>性质六</li>
</ol></li>
<li>二叉树存储结构：在计算机中，二叉树通常采用链式存储结构，对于满二叉树和完全二叉树来说，可以按层序进行顺序存储</li>
<li>二叉树的遍历：
<ol>
<li>前序遍历（DLR）：根结点、左子树、右子树</li>
<li>中序遍历（LDR）：左子树、根结点、右子树</li>
<li>后序遍历（LRD）：左子树、右子树、根结点</li>
<li>如果知道了前序序列和中序序列或者知道了中序序列和后序序列可以唯一地恢复该二叉树，但是如果知道了前序序列和后序序列，不能唯一地恢复该二叉树</li>
</ol></li>
</ol></li>
<li>查找技术：
<ol>
<li>顺序查找：对于大的线性表效率低，但是对于无序表和链表只能用顺序查找</li>
<li>二分法查找：只适用于顺序存储的有序表</li>
</ol></li>
<li>排序技术：
<ol>
<li>交换类排序方式：
<ol>
<li>冒泡排序：最坏-- n(n-1)/2</li>
<li>快速排序：最坏-- n(n-1)/2 一般比冒泡要好</li>
</ol></li>
<li>插入类排序：
<ol>
<li>简单插入排序：最坏--n（n-1）/2 效率与冒泡相同</li>
<li>希尔排序：最坏效率与所选取增量有关</li>
</ol></li>
<li>选择类排序：
<ol>
<li>简单选择排序法：最坏--n(n-1)/2</li>
<li>堆排序法：最坏-- nlog2n 对于较小规模不适用，对于较大规模线性表很有效</li>
</ol></li>
</ol></li>
</ol>

<h2 id="toc_3">软件工程基础</h2>

<ol>
<li>软件的定义及软件的特点：
<ol>
<li>程序是软件开发人员根据用户需求开发的、用程序设计语言描述的、适合计算机执行的指令序列</li>
<li>特点：
<ol>
<li>软件是一种逻辑实体，而不是物理实体，具有抽象性</li>
<li>软件的生产与硬件不同，没有明显的制作过程</li>
<li>软件在运行、使用期间不存在磨损、老化问题</li>
<li>软件的开发、运行对计算机系统具有依赖性</li>
<li>软件复杂性高，成本昂贵</li>
<li>软件开发涉及诸多社会因素</li>
</ol></li>
<li>分类：
<ol>
<li>应用软件：为解决特定领域的应用而开发的软件</li>
<li>系统软件：计算机管理自身资源、提高计算机使用效率并服务于其他程序的软件。如，操作系统，编译程序，汇编程序，网络软件，数据库管理系统</li>
<li>支撑软件（工具软件）：介于系统软件和应用软件之间，协助用户开发软件的工具箱软件</li>
</ol></li>
</ol></li>
<li>软件危机与软件工程
<ol>
<li>软件危机：泛指在计算机软件的开发和维护过程中所遇到的一系列严重问题</li>
<li>软件工程：将系统化的、规范的、可度量的方法应用于软件的开发、运行和维护的过程，即将工程化应用于软件中</li>
<li>软件工程三要素：方法、工具、过程</li>
</ol></li>
<li>软件过程与软件生命周期：
<ol>
<li>软件过程：软件过程就是把输入转化为一组彼此相关的资源和活动</li>
<li>软件生命周期：软件从提出、实现、使用、维护到停止使用退役的过程称为软件的生命周期。
<ol>
<li>可行性研究与计划制定</li>
<li>需求分析</li>
<li>软件设计</li>
<li>编码</li>
<li>软件测试</li>
<li>运行与维护</li>
</ol></li>
</ol></li>
<li>软件工程的目标与原则：
<ol>
<li>目标：在给定成本、进度的前提下，开发具有有效性、可靠性、可理解性、可维护性、可重用性、可适应性、可移植性、可追踪性和可操作性且满足用户需求的产品</li>
<li>研究内容：
<ol>
<li>软件开发技术：软件开发方法学、开发过程、开发工具、软件工程环境</li>
<li>软件工程管理：软件管理学、软件工程经济学、软件心理学</li>
<li>软件工程的原则：
<ol>
<li>抽象</li>
<li>信息隐蔽</li>
<li>模块化</li>
<li>局部化</li>
<li>确定性</li>
<li>一致性</li>
<li>完备性</li>
<li>可验证性</li>
</ol></li>
</ol></li>
</ol></li>
<li>结构化分析方法
<ol>
<li>软件开发方法：分析方法、设计方法、程序设计方法</li>
<li>结构化方法：结构化分析方法、结构化设计方法、结构化编程方法</li>
</ol></li>
<li>需求分析与需求分析方法
<ol>
<li>需求分析：用户对目标软件系统在功能、行为、性能、设计约束等方面的期望。需求分析的任务是发现需求、求精、建模和定义需求的过程。</li>
<li>需求分析方法：
<ol>
<li>结构化分析方法：面向数据流的结构化分析方法（SA）、面向数据结构的Jackson方法（JSD）、面向数据结构的结构化数据系统开发方法（DSSD）</li>
<li>面向对象的分析方法（OOA）：</li>
</ol></li>
</ol></li>
<li>结构化分析方法：
<ol>
<li>实质：着眼于数据流，自顶向下，逐层分解，建立系统的处理流程，以数据流图和数据字典为主要工具，建立系统的逻辑模型</li>
<li>工具：
<ol>
<li>数据流图（DFD）：
<ol>
<li>元素：加工、数据流、数据源、数据的源点和终点</li>
<li>步骤：由外向里，自顶向下，逐层分解。</li>
</ol></li>
<li>数据字典（DD）：对所有与系统相关的数据元素的一个有组织的列表，以及精确、严格定义。</li>
<li>判定树</li>
<li>判定表</li>
</ol></li>
</ol></li>
<li>软件需求规格说明书
<ol>
<li>内容：软件的目标，功能需求、性能需求、外部接口、属性及约束条件</li>
<li>特点
<ol>
<li>正确性</li>
<li>无歧义性</li>
<li>完整性</li>
<li>可验证性</li>
<li>一致性</li>
<li>可理解性</li>
<li>可修改性</li>
<li>可追踪性</li>
</ol></li>
</ol></li>
<li>结构化设计方法
<ol>
<li>软件设计基本概念
<ol>
<li>目标：用比较抽象概括的方式确定目标系统如何完成预定的任务，即软件设计是确定系统的物理模型</li>
<li>包括：结构设计、数据设计、接口设计、过程设计</li>
<li>一般过程：软件设计是一个迭代过程，先进行高层次的结构设计，后进行低层次的过程设计，穿插进行数据设计和接口设计</li>
<li>基本原理：
<ol>
<li>抽象</li>
<li>逐步求精和模块化</li>
<li>信息隐蔽和局部化</li>
<li>模块独立性（高内聚、低耦合）</li>
</ol></li>
<li>结构化设计方法：采取最佳的可能方法设计系统的各个组成部分以及各成分之间的内部联系的技术</li>
</ol></li>
<li>概要设计
<ol>
<li>设计软件系统结构</li>
<li>数据结构及数据库设计</li>
<li>编写概要设计文档</li>
<li>概要设计文档评审</li>
<li>常用软件结构设计工具是结构图（SC）
<ol>
<li>构成：一般模块、数据信息、控制信息</li>
<li>四种模块：传入、传出、变化、协调</li>
<li>术语：
<ol>
<li>深度：表示控制的层数</li>
<li>宽度：整体控制跨度</li>
<li>扇入：调用一个给定模块的个数</li>
<li>扇出：一个模块调用的其他模块数</li>
<li>原子模块：树中位于叶子结点的模块</li>
</ol></li>
</ol></li>
<li>面向数据流的结构化设计方法
<ol>
<li>数据流类型
<ol>
<li>变换型</li>
<li>实物型</li>
</ol></li>
<li>面向数据流设计方法的实施要点与设计过程
<ol>
<li>分析、确认数据流图的类型，区分是事物型还是变换型</li>
<li>说明数据流的边界</li>
<li>把数据流图映射为程序结构</li>
<li>根据设计准则对产生的结构进行细化和求精</li>
</ol></li>
</ol></li>
<li>设计的准则
<ol>
<li>提高模块独立性</li>
<li>模块规模适中</li>
<li>深度、宽度、扇出和扇入适当</li>
<li>使模块的作用域在该模块的控制域内</li>
<li>应减少模块的接口和界面的复杂性</li>
<li>设计成单入口、单出口的模块</li>
<li>设计功能可预测的模块</li>
</ol></li>
<li>详细设计
<ol>
<li>确定模块内部的详细执行过程，包括局部数据组织、控制流、每一步具体处理要求和各种实现细节等</li>
<li>设计工具
<ol>
<li>图形工具：程序流程图（PFD）、N-S图、PAD图、HIOP图</li>
<li>表格工具：判定表</li>
<li>语言工具：PDL</li>
</ol></li>
</ol></li>
</ol></li>
</ol></li>
<li>软件测试
<ol>
<li>目的和定义
<ol>
<li>定义：
<ol>
<li>在规定条件下运行系统或构件的过程；在此过程中观察和记录结果，并对系统或构件的某些方面给出评价</li>
<li>软件项目的过程：检测现有状况或所需状况的不同（bug），并评估软件的特性</li>
</ol></li>
<li>目的：
<ol>
<li>软件测试是为了发现错误而执行程序的过程</li>
<li>一个好的测试用例是指很有可能找到迄今为止尚未发现的错误的用例</li>
<li>一个成功的测试是发现了至今尚未发现的错误的测试</li>
</ol></li>
</ol></li>
<li>软件测试的准则
<ol>
<li>所有测试都应追溯到需求</li>
<li>严格执行测试计划，排除测试的随意性</li>
<li>充分主语测试中的群集现象</li>
<li>程序员应该避免检查自己的程序</li>
<li>穷举测试不可能</li>
<li>妥善保存测试计划、测试用例、出错统计和最终分析报告，为维护提供方便</li>
</ol></li>
<li>软件测试方法与技术综述
<ol>
<li>静态测试与动态测试
<ol>
<li>静态测试：变量检查、命名和类型审查、程序逻辑审查、程序语法审查和程序结构检查
<ol>
<li>代码检查包括：代码审查、代码走查、桌面检查、静态分析</li>
</ol></li>
<li>动态测试：设计高效合理的测试用例是动态测试的关键</li>
</ol></li>
<li>白盒测试方法与测试用例设计
<ol>
<li>白盒测试把测试对象看作打开的盒子，允许测试人员利用程序内部的逻辑机构及有关信息来设计或选择测试用例</li>
<li>基本原则：保证所测模块中每一独立路径至少执行一次；保证所测模块所有判断的每一分枝至少执行一次；保证所测模块每一循环都在边界条件和一般条件下至少各执行一次；验证所有内部数据结构的有效性</li>
<li>分类：
<ol>
<li>等价类划分法：
<ol>
<li>有效等价类：合理、有意义的输入数据构成的集合</li>
<li>无效等价类：不合理、无意义的输入数据构成的集合</li>
</ol></li>
<li>边界值分析法：一般多用边界值分析法来补充等价类划分法</li>
<li>错误推测法</li>
</ol></li>
</ol></li>
</ol></li>
<li>软件测试的粗略
<ol>
<li>单元测试：依据详细设计说明书和源程序，采用静态分析和动态测试。对动态测试通常以白盒测试为主，黑盒测试为辅。目的是发现各模块内部可能存在的各种错误
<ol>
<li>测试内容：模块接口测试、局部数据结构测试、重要执行路径检查、出错处理测试、影响以上各点及其他相关点的边界条件测试</li>
</ol></li>
<li>集成测试：依据概要设计说明书，目的是发现与接口有关的错误
<ol>
<li>非增量方式：将测试好的每一个软件单元一次性组装在一起再进行整体测试</li>
<li>增量方式：将已经测试好的模块逐步组装成较大系统，在组装过程中边接边测，以发现连接过程中产生的问题
<ol>
<li>自顶向下：较早显示整个程序轮廓，较早验证主要的控制和判断点。但是当测试上层模块时使用的桩模块较多，很难摸清真实模块的全部功能，导致部分测试推迟</li>
<li>自底向上：实际测试用例比较容易，但是在早期不能显示出程序的轮廓</li>
<li>自顶向下和自底向上相结合</li>
</ol></li>
</ol></li>
<li>确认测试：验证软件的功能和性能及其他特性是否满足了需求规格说明中确定的各种需求，以及软件配置是否完全，正确。黑盒测试</li>
<li>系统测试：将通过确认测试的软件，作为整个基于计算机系统的一个元素，与计算机硬件、外设、支持软件、数据和人员等其他元素组合在一起，在实际运行环境下对计算机系统进行一系列的集成测试和确认测试</li>
</ol></li>
</ol></li>
<li>程序的调试 
<ol>
<li>目的：诊断和改正程序中的错误（软件测试是尽可能多地发现软件中的错误，贯穿整个软件的生命周期，调试主要发生在开发阶段）</li>
<li>基本步骤
<ol>
<li>错误定位：占据绝大部分工作量</li>
<li>修改设计和代码，以排除错误</li>
<li>进行回归测试防止引进新的错误</li>
</ol></li>
<li>原则：
<ol>
<li>确定错误原则
<ol>
<li>分析思考与错误征兆有关的信息</li>
<li>避开死胡同</li>
<li>只把调试工具当辅助手段来用</li>
<li>避免使用试探法，最多只能当作最后手段</li>
</ol></li>
<li>修改错误的原则
<ol>
<li>在出现错误的地方，有可能还有别的错误</li>
<li>不要只修改了错误的征兆或表现，而没有修改错误本身</li>
<li>注意修改一个错误的同时可能引进一个新的错误</li>
<li>修改错误的过程将迫使人们暂时回到程序设计阶段</li>
<li>修改源代码，不要改变目标代码</li>
</ol></li>
</ol></li>
<li>软件调试方法：静态调试为主，动态调试为辅
<ol>
<li>强行排错法：设置断点，程序暂停，观察程序状态，继续运行程序</li>
<li>回溯法：适用于小规模程序排错</li>
<li>原因排除法：通过演绎和归纳以及二分法</li>
</ol></li>
</ol></li>
</ol>

		</div>
	</article>
	<div class="share-comment">
	 

	  

	  

	</div>
</div>        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

</body>
</html>