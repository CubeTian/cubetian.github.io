<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[程序猿CubeTian]]></title>
  <link href="https://cubetian.github.io/atom.xml" rel="self"/>
  <link href="https://cubetian.github.io/"/>
  <updated>2019-10-01T23:41:15+08:00</updated>
  <id>https://cubetian.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[GSPM笔记]]></title>
    <link href="https://cubetian.github.io/15699393940279.html"/>
    <updated>2019-10-01T22:16:34+08:00</updated>
    <id>https://cubetian.github.io/15699393940279.html</id>
    <content type="html"><![CDATA[
<p>用于微磁模拟的Gauss-Seidel投影方法</p>

<p>微磁学仿真中的主要困难之一是交换场引入了严格的时间步长约束。使用标准的显式积分器会导致亚皮秒级的物理时间步长，通常比最快的物理时间尺度小两个数量级。直接的隐式积分器需要解决复杂的耦合系统。在本文中我们介绍了一种隐式方法，其复杂度可与隐式求解标量热方程相媲美。该方法是基于Gauss-Seidel实施的针对旋磁项的分数阶隐式求解器和针对谐波图的热流投影方法的组合。这种方法是我们能够对微米级元素中磁化强度进行完全解析的计算。</p>

<p>介绍<br/>
从科学和技术的观点来看，铁磁薄膜中磁化分布的动力学是一个有趣且重要的问题。通常，这些薄膜的主要兴趣在于它们在磁记录行业中的应用。最近，对将它们用作磁存储器件（MRAM）的兴趣已经激发了研究该主题的更大动力。由于缺陷，杂质和热噪声在纳米厚度的膜中对磁化场的动力学起着重要作用，因此它也成为研究某些纳米级物理的理想场所[4，7，8，10，18] </p>

<p>铁磁材料中磁化分布的弛豫(relaxation)过程由Landau–Lifshitz方程[12，14]描述<br/>
\[\mathbf{M}_{t}=-\gamma \mathbf{M} \times \mathcal{H}-\frac{\gamma \alpha}{M_{s}} \mathbf{M} \times(\mathbf{M} \times \mathcal{H}) \tag1\]<br/>
其中\(|\mathbf{M}|=M_{s}\)是饱和磁化强度，通常设置为一个远离居里温度的常数。右边第一项是旋磁项，其中\(\gamma\)是旋磁比。右边第二项是阻尼项，其中\(\alpha\)是无量纲的阻尼系数。\(\mathcal{H}\)项是局部场，由Landau–Lifshitz自由能函数计算得到<br/>
\[<br/>
\mathcal{H}=-\frac{\delta F}{\delta \mathbf{M}} \tag2<br/>
\]<br/>
\[<br/>
F[\mathbf{M}]=\frac{1}{2} \int_{\Omega}\left\{\Phi\left(\frac{\mathbf{M}}{M_{s}}\right)+\frac{A}{M_{s}^{2}}|\nabla \mathbf{M}|^{2}-2 \mu_{0} \mathbf{H}_{e} \cdot \mathbf{M}\right\} d x+\frac{\mu_{0}}{2} \int_{\mathbb{R}^{3}}|\nabla U|^{2} d x<br/>
\tag3\]<br/>
在（3）中，\(A\)是交换常数，\(\frac{A}{M_{s}^{2}}|\nabla M|^{2}\)是自旋之间的交换相互作用能。\(\Phi\left(\frac{\mathrm{M}}{M_{s}}\right)\)是自材料的各向异性的能量。\(\mu_0\)是真空磁导率(S.I.中\(\mu_0=4\pi\times10^{-7} N/A^2\))\(-2 \mu_{0} \mathbf{H}_{e} \cdot \mathbf{M}\)是由外部施加场产生的能量。\(\Omega\)是材料所占的体积。最后,(3)中的最后一项是由材料内部磁化分布感应的磁场产生的能量。感应场\(\mathbf{H}_{s}=-\nabla U\)可以通过以下求解<br/>
\[<br/>
\Delta U=\left\{\begin{array}{ll}{\nabla \cdot \mathbf{M}} &amp; {\text { in } \Omega} \\ {0} &amp; {\text { outside } \Omega}\end{array}\right.<br/>
 \tag4\]<br/>
连同跳跃条件<br/>
\[<br/>
\begin{aligned} \left[U\right]_{\partial \Omega} &amp;=0 \\\left[\frac{\partial U}{\partial v}\right]_{\partial \Omega} &amp;=-\mathbf{M} \cdot v\end{aligned}<br/>
\tag5\]<br/>
在域\(\Omega\)的边界。在(5)中,我们用\([v]_{\partial \Omega}\)表示\(v\)在\(\Omega\)边界的跳跃。<br/>
\[<br/>
[v]_{ | \partial \Omega}(x)=\lim _{y \rightarrow x \atop y \in \overline{\Omega}^{c}} v(y)-\lim _{y \rightarrow x \atop y \in \Omega} v(y)<br/>
\]<br/>
方程(4)，与边界条件(5)的解为<br/>
\[<br/>
\nabla U(x)=\nabla \int_{\Omega} \nabla N(x-y) \cdot \mathbf{M}(y) d y \tag6<br/>
\]<br/>
其中\(N(x)=-\frac{1}{4 \pi} \frac{1}{|x|}\)是牛顿势。<br/>
Landau–Lifshitz方程(1)中旋磁项是一个保守项，而阻尼项是耗散的。<br/>
了解Landau–Lifshitz系统(1)的长期动力学对于设计有效的计算机磁化切换机制具有实际意义。<br/>
存储单元[4，18]。数值模拟已成为研究铁磁材料中静态和动态问题的重要工具[1、2、6、9、11、15、16、19、26]。在磁化反转过程的仿真中，重要的是能够解析出所涉及的不同小长度尺度，尤其是磁畴壁和磁涡旋，因为它们是在亚微米图案化NiFe实验中观察到的开关异常的原因。数组[17，21，22，23，24]。明确的数字格式（例如四阶Runge-Kutta或具有某种自适应时间步长程序的预测器-校正器方案）是目前最常用的Landau-Lifshitz方程模拟方法。尽管显式方案可以在空间和时间上达到很高的准确性，时间步长的大小受到数值方案稳定性的严格限制。对于坡莫合金的物理常数(\(M_{s}=8.0 \times 10^{5}\) Ampere \(/ \mathrm{m}, K_{u}=5.0 \times 10^{2} \mathrm{J} / \mathrm{m}^{3}, A=1.3 \times 10^{-11} \mathrm{J} / \mathrm{m}, \gamma=1.76 \times 10^{11} T^{-1}s^{-1}\)),单位大小\(\Delta x=0.004 \mu \mathrm{m}\)（在1 µm长的样本中为256个网格点)，并且使用四阶Runge–Kutta，我们需要使用大约\(\Delta t\)≈.25皮秒量级的时间步长来实现数值稳定性。如果将像元大小减小10倍，则必须将时间步长\(\Delta t\)减小100倍。此外，在典型的磁滞回线中，相对于所施加磁场的变化，平均磁化强度的变化表现为 在切换场附近和远离切换场有很大的不同，相距不远，并且随着所施加的场接近切换场而突然改变。这些考虑表明，需要具有时间适应性的Landau–Lifshitz方程数值积分方案。 构建这种方法的第一步是构建无条件稳定的数值方案。<br/>
为了克服显式方案的稳定性约束，通常采用隐式方案[15]。但是，由于在Landau–Lifshitz方程（1）中的回旋和阻尼项中都存在很强的非线性，因此系统的直接隐式离散化效率不高且难以实现。为了理解问题的症结，让我们将注意力集中在仅交换条件在（2）中成立的情况下。在这种情况下，\(\mathcal{H}=\Delta \mathbf{m}\)和Landau–Lifshitz方程简化为<br/>
\[<br/>
\mathbf{m}_{t}=-\mathbf{m} \times \Delta \mathbf{m}-\mathbf{m} \times(\mathbf{m} \times \Delta \mathbf{m}) \tag7<br/>
\]<br/>
我们的目标是为（7）开发一个稳定的数值方案，使我们可以使用较大的时间步长。旋磁项和阻尼项将需要不同的处理。当仅存在阻尼项时，方程（7）变为<br/>
\[<br/>
\mathbf{m}_{t}=-\mathbf{m} \times(\mathbf{m} \times \Delta \mathbf{m})=\Delta \mathbf{m}+|\nabla \mathbf{m}|^{2} \mathbf{m}<br/>
\tag 8\]<br/>
该方程式描述了谐波图的热流。在[5]中，为该方程引入了一个简单的投影方案。与用于模拟方程(8)的其他方案相比，该方案被证明是无条件稳定和高效的。<br/>
在本文中，我们将主要关注Landau–Lifshitz方程中的旋磁项:<br/>
\[<br/>
\mathbf{m}_{t}=-\mathbf{m} \times \Delta \mathbf{m}<br/>
\tag9\]<br/>
该方程为谐波图的辛流[3，25]。我们为（9）引入了一种简单有效的方案，该方案也是无条件稳定的。这个新方案的关键是观察到，由于方程的矢量积结构，高斯-赛德尔（Gauss-Seidel）类型的技术显着提高了Landau-Lifshitz方程显式格式的稳定性。然后，将此高斯－赛德尔技术与拆分过程一起使用，以获得有效的，更重要的是无条件稳定的方案。除了简单性和无条件的稳定性外，该方案在某种意义上也是刻板的。结合阻尼部分的投影方案，我们对整个Landau–Lifshitz方程有一个无条件稳定的方案。<br/>
我们将我们的方法应用于图案化亚微米阵列中异常切换的仿真。 Jing Shi等人[17，21–24]在实验中观察到了这一点捕获的磁化涡旋是开关异常的原因。 这个问题的数值模拟非常苛刻。 为了计算磁滞回线和剩余磁化曲线，需要运行100多个到稳态的演化，同时，在每个方向上需要256个以上的网格点才能解决涡旋和畴壁。<br/>
本文的组织结构如下：在第2节中，我们将通过分析一个简单的示例来研究Landau–Lifshitz方程的矢量性质对几种常用时间步进程序的稳定性的影响。我们介绍了高斯－赛德尔技术，并对这一技术提高了显式方案的稳定性进行了重要观察。在第3节中，我们引入了利用高斯-赛德尔（Gauss-Seidel）技术的（9）的分步程序。上一节的分析表明，我们的方案是无条件稳定的。在第4节中，我们将我们的方案的性能与两种不同的显式方案的性能进行了谐波图的辛流动。在第5节中，我们结合了新方法 用[5]中推导的谐波图的热流投影方法，并为整个Landau-Lifshitz方程引入高斯-塞德尔投影方法。在第6节中，我们回顾了一些开关异常实验，并给出了使用高斯-赛德尔投影法进行的数值模拟。我们能够解析涡旋动力学，并准确模拟[17，21–24]中观察到的切换异常。</p>

<p>一个简答的例子</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派入门笔记]]></title>
    <link href="https://cubetian.github.io/15696705812938.html"/>
    <updated>2019-09-28T19:36:21+08:00</updated>
    <id>https://cubetian.github.io/15696705812938.html</id>
    <content type="html"><![CDATA[
<p>本尊要开始接触树莓派啦</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[想要的书目录]]></title>
    <link href="https://cubetian.github.io/15680140350374.html"/>
    <updated>2019-09-09T15:27:15+08:00</updated>
    <id>https://cubetian.github.io/15680140350374.html</id>
    <content type="html"><![CDATA[
<p>《运筹与管理科学丛书》的部分专著：</p>

<ol>
<li>非线性优化计算方法 袁亚湘 著 2008年2月 9787030208835</li>
<li>博弈论与非线性分析 俞建 著 2008年2月 9787030207203</li>
<li>蚁群优化算法 马良等著 2008年2月 9787030205681</li>
<li>组合预测方法有效性理论及其应用 陈友华著 2008年2月 9787030202130</li>
<li>非光滑优化 高岩 著 2008年4月</li>
<li>离散时间排队论 田乃硕 徐秀丽 马占友 著 2008年6月</li>
<li>动态合作博弈 高红伟[俄] 彼得罗相著 2009年3月</li>
<li>锥约束优化——最优性理论与增广Lagrange方法 张立卫 著 2010年1月</li>
<li>Kernel Function-based Interior-point Algorithms for Conic Optimization Yanqin Bai 著2010年7月</li>
<li>整数规划 孙小玲 李端 著 2010年11月</li>
<li>竞争与合作——数学模型及供应链管理 葛泽慧 孟志青 胡奇英著 2011年6月</li>
<li>线性规划计算（上） 潘平奇 著 2012年4月</li>
<li>线性规划计算（下） 潘平奇 著 2012年5月</li>
<li>设施选址问题的近似算法 徐大川 张家伟著 2013年1月 9787030352408</li>
<li>模糊优化方法与应用  刘彦奎   陈艳菊   刘颖   秦蕊 著 2013年3月</li>
<li>变分分析与优化  张立卫   吴佳   张艺   著 2013年6月</li>
<li>线性锥优化  方述诚    邢文训    著 2013年8月</li>
<li>网络最优化 谢政 著 2014年6月</li>
<li>网上拍卖下的库存管理 刘树人 著 2014年8月</li>
<li>图与网络流理论（第二版） 田丰，张运清 著 2015年1月</li>
<li>组合矩阵的结构指数 柳柏濂 黄宇飞 著 2015年1月</li>
<li>马尔可夫决策过程理论与应用 刘克 编著 2015年2月</li>
<li>最优化方法 杨庆之 编著 2015年3月</li>
<li>图论基础教程（英文版） 徐俊明 著 2015年4月</li>
<li>广义凸性及其应用 杨新民，戎卫东 著 2015年12月</li>
<li>排队博弈论基础 王金亭 著 2016年6月</li>
<li>不良贷款的回收：数据背后的故事 杨晓光，陈暮紫，陈敏 著 2017年6月</li>
<li>参数可信性优化方法 刘彦奎，白雪洁，杨凯 著 2017年12月</li>
<li>非线性方程组数值方法 范金燕，袁亚湘 著 2018年3月</li>
</ol>

<p>《信息与计算科学》丛书</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SAS程序结构]]></title>
    <link href="https://cubetian.github.io/15673304578082.html"/>
    <updated>2019-09-01T17:34:17+08:00</updated>
    <id>https://cubetian.github.io/15673304578082.html</id>
    <content type="html"><![CDATA[
<p>DATA步-PROC步-OUTPUT步</p>

<h3 id="toc_0">DATA步：此步骤涉及将所需数据集加载到SAS存储器中并识别数据集的变量（也称为列）。 它还捕获记录（也称为观察或主体）。</h3>

<p>DATA;  数据集的创建<br/>
INFILE ‘文件路径’<br/>
INPUT;  定义变量<br/>
CARDS;<br/>
;<br/>
RUN;<br/>
. 表示数据缺失<br/>
过程步<br/>
proc ;<br/>
run;</p>

<h2 id="toc_1">SAS 概述</h2>

<p>SAS常用组件<br/>
Base 核心模块<br/>
Graph 图表<br/>
Stat 统计分析：方差分析、回归、多变量分析、生存分析、心理分析<br/>
Or 行动调查<br/>
Ets 计量经济学和时间序列分析<br/>
IML CInteractive 矩阵语言<br/>
AF 应用设施<br/>
QC 质量控制<br/>
INSIGHT 数据挖掘<br/>
PH 临床试验分析<br/>
Enterprise Miner 数据挖掘</p>

<p>SAS的窗口</p>

<ol>
<li>日志窗口：执行窗口，可以检查SAS程序的执行</li>
<li>编辑器窗口：写所有代码，像记事本，默认提交后清除文本，可在工具-选项-编辑器中调整</li>
<li>输出窗口：可以看到程序的输出</li>
<li>结果窗口：</li>
<li>资源管理器窗口</li>
</ol>

<p>SAS库</p>

<ol>
<li>临时库(WORK库)：这是SAS的默认库。如果我们创建的数据不选择其他库将默认存储于临时库。可以在资源管理器窗口看到WORK库。如果在关闭或者重启SAS前没有将该数据存储于一个永久库，数据将会丢失。</li>
</ol>

<h2 id="toc_2">SAS Enterprise Guide</h2>

<p>学习教程的过程中，您将学习以下内容：</p>

<ul>
<li>创建和保存项目</li>
<li>向项目添加 SAS 数据</li>
<li>从文本文件导入数据</li>
<li>创建和修改列表报表</li>
<li>创建条形图和饼图</li>
<li>使用查询连接表</li>
<li>使用查询创建计算列</li>
<li>生成汇总统计量表</li>
<li>基于数据运行线性模型分析</li>
<li>将多个报表组合成单个文档</li>
</ul>

<p>在继续相应教程之前，您需要首先了解一些有关 SAS Enterprise Guide 和 SAS 软件之间的关系。</p>

<h2 id="toc_3">SAS程序语法</h2>

<h3 id="toc_4">注释</h3>

<p>/*<br/><br/>
 *   */</p>

<h3 id="toc_5">从外部文件中导入数据</h3>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[计算机二级python]]></title>
    <link href="https://cubetian.github.io/15655035745414.html"/>
    <updated>2019-08-11T14:06:14+08:00</updated>
    <id>https://cubetian.github.io/15655035745414.html</id>
    <content type="html"><![CDATA[
<ul>
<li>注释 #</li>
<li>续行符 反斜杠 \</li>
<li>命名 大小字母、下划线、数字、汉字<br/>
但首字母不能是数字</li>
<li>保留字：<br/>
False, True, and, as, break, continue, def, del, elif, else, except, for, from, global, if, import, in, not, or, return, try, while (22个，2个大写)<br/>
None, finally, lambda, pass, with</li>
<li>jieba.lcut(s,cut_all=True)<br/>
*0x4DC0 是一个十六进制数，它对应的 Unicode 编码是中国古老的《易经》六十四卦的第一卦，请输出第 51 卦（震卦）对应的 Unicode 编码的二进制、十进制、八进制和十六进制格式。
<code>print(&quot;二进制{0:b}、十进制{0:d}、八进制{0:o}、十六进制{0:x}&quot;.format(0x4DC0+50))
</code></li>
<li>字符串的索引：<br/>
正向索引：最左侧字符序号为0，向右依次递增，最右侧为L-1<br/>
反向索引：最右侧字符序号为-1，向左依次递减，最左侧为-L</li>
<li>字符串的索引：<br/>
切片部分必须连续，[a=0,b=L-1,step=1] </li>
<li>文件操作
<code>
f = open(&#39;file.csv&#39;,&#39;r&#39;,encoding=&#39;GB2312&#39;)<br/>
ls = []<br/>
for line in f.readlines():<br/>
line.replace(&#39;\n&#39;,&#39;&#39;)<br/>
ls.append(line.split(&#39;,&#39;))
</code></li>
<li>字典操作<br/>
d[key] = d.get(key,0)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[计算机二级 公共知识]]></title>
    <link href="https://cubetian.github.io/15653132926815.html"/>
    <updated>2019-08-09T09:14:52+08:00</updated>
    <id>https://cubetian.github.io/15653132926815.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">程序设计基础</h2>

<ol>
<li>程序设计的方法和风格：“清晰第一、效率第二”
<ol>
<li>源程序文档化
<ol>
<li>符号名的命名：</li>
<li>程序注释：</li>
<li>视觉组织：</li>
</ol></li>
<li>数据说明方法
<ol>
<li>数据说明次序规范化</li>
<li>说明语句中变量安排有序化</li>
<li>使用注释来说明复杂的数据结构</li>
</ol></li>
<li>语句的结构</li>
<li>输入和输出</li>
</ol></li>
<li>结构化程序设计
<ol>
<li>原则：自顶向下、逐步求精、模块化、限制使用goto语句</li>
</ol></li>
<li>结构化程序的基本结构与特点
<ol>
<li>顺序结构</li>
<li>选择结构</li>
<li>循环结构</li>
</ol></li>
<li>结构化程序设计原则和方法的应用</li>
<li>面向对象的程序设计
<ol>
<li>面向对象方法的优点
<ol>
<li>与人类习惯的思维方法一致</li>
<li>稳定性好</li>
<li>可重用性好</li>
<li>易于开发大型软件产品</li>
<li>可维护性好</li>
</ol></li>
<li>基本概念
<ol>
<li>对象：应用领域中有意义的，与所要解决问题有关的任何事物都可以作为对象，它既可以是具体的物理实体的抽象，也可以是人为的概念，或者是任何有明确边界和意义的东西。由一组表示其静态性质的属性和它可执行的一组操作组成
<ol>
<li>标识唯一性：由对象的内在本质区分，而不是通过表述来区分</li>
<li>分类性</li>
<li>多态性</li>
<li>封装性</li>
</ol></li>
<li>类和实例：类是具有共同属性共同方法的对象的集合。当使用对象这个词时，既可以指具体对象，也可以指一般对象，但是实例必然是一个具体对象。</li>
<li>消息：消息是一个实例与另一个实例之间传递的信息，它请求对象执行某一处理或回答某一要求的信息，它统一了数据流和控制流，组成：
<ol>
<li>接收消息的对象名称</li>
<li>消息标识符（消息名）</li>
<li>零个或多个参数</li>
</ol></li>
<li>继承：是使用已有的类定义作为基础建立新类的定义技术
<ol>
<li>单继承：一个类只允许有一个父类</li>
<li>多继承：一个类允许有多个父类，功能更强，使用方便，但是要避免二义性</li>
</ol></li>
<li>多态性：对象根据所接受的信息做出动作，同样的消息被不同的对象接收时可导致完全不同的行动。在面对对象的软件技术中，多态性是指子类对象可以像父类对象那样使用，同样的消息既可以发送给父类对象，又可以发送给子类对象</li>
</ol></li>
</ol></li>
</ol>

<h2 id="toc_1">数据库知识基础</h2>

<ol>
<li>数据库系统的基本概念
<ol>
<li>数据（DATA）：描述事物的符号记录
<ol>
<li>数据分为临时性、持久性</li>
<li>数据有 型 、值 之分</li>
<li>将多种相关数据以一定的结构方式组合构成特定的数据框架，这样的数据框架称为数据结构，数据库在特定的条件下称为数据模式</li>
</ol></li>
<li>数据库（DATABASE，DB）：数据的集合，它具有统一的结构形式并存放于统一的存储介质内，是多种应用数据的集成，并可被各个应用程序所共享</li>
<li>数据库管理系统（Database Managerment System DBMS）：是数据库的机构，它是一种系统软件，负责数据库中的数据组织，数据操控，数据维护、控制及保护和数据服务<br/>
    功能：
<ol>
<li>数据模式定义</li>
<li>数据存取的物理构建</li>
<li>数据操纵</li>
<li>数据的完整性、安全性定义与检查：数据的完整性与安全性的维护是数据库管理系统的基本功能</li>
<li>数据库的并发控制与故障恢复</li>
<li>数据的服务：数据的拷贝、转存、重组、性能检测、分析<br/>
数据语言：</li>
<li>数据定义语言（DDL）：负责数据的模式定义与数据的物理存储构建</li>
<li>数据操作语言（DML）：负责数据的操作，查增删改</li>
<li>数据控制语言（DCL）：负责数据完整性、安全性的定义与检查以及并发控制、故障恢复等功能</li>
</ol></li>
<li>数据库管理员（DBA）：
<ol>
<li>数据库设计（Database Design）</li>
<li>数据库维护</li>
<li>改善系统性能，提高系统效率</li>
</ol></li>
<li>数据库系统（DBS）
<ol>
<li>数据库（数据）</li>
<li>数据库管理系统软件（软件）</li>
<li>数据库管理员（人员）</li>
<li>系统平台之一——硬件平台（硬件）：计算机、网络</li>
<li>系统平台之二——软件平台（软件）：操作系统、数据库系统开发工具</li>
</ol></li>
<li>数据库应用系统（DBAS）：数据库系统+应用软件+应用界面
<ol>
<li>数据库</li>
<li>数据库管理系统</li>
<li>数据库管理员</li>
<li>硬件平台</li>
<li>软件平台</li>
<li>应用软件</li>
<li>应用界面</li>
</ol></li>
</ol></li>
<li>数据库发展
<ol>
<li>文件系统阶段</li>
<li>层次数据库与网状数据库系统阶段</li>
<li>关系数据库系统阶段</li>
<li>未来：
<ol>
<li>面向对象数据库系统</li>
<li>知识库系统</li>
<li>关系数据库系统的扩充</li>
</ol></li>
</ol></li>
<li>数据库系统的基本特点
<ol>
<li>数据的集成性：
<ol>
<li>统一的数据结构方式</li>
<li>按照多个应用的需要组织全局的统一的数据结构</li>
<li>数据模式是多个应用共同的、全局的数据结构</li>
</ol></li>
<li>数据的高共享性与低冗余性</li>
<li>数据的独立性
<ol>
<li>物理独立性：数据库的物理结构改变不影响逻辑结构</li>
<li>逻辑独立性：数据库总体逻辑改变不影响相应的应用程序</li>
</ol></li>
<li>数据的统一管理与控制
<ol>
<li>数据的完整性检查</li>
<li>数据的安全性保护</li>
<li>并发控制</li>
</ol></li>
</ol></li>
<li>数据库系统的内部结构体系：数据库在其内部有三级模式及二级映射
<ol>
<li>三级模式
<ol>
<li>概念模式：数据库系统中全局数据逻辑结构的描述，是全体用户公用数据视图</li>
<li>外模式（子模式、用户模式）：用户的数据视图</li>
<li>内模式（物理模式）：数据物理存储结构与物理存取方法</li>
</ol></li>
<li>二级映射
<ol>
<li>概念模式到内模式的映射</li>
<li>外模式到概念模式到映射</li>
</ol></li>
</ol></li>
<li>数据模型：数据库中的数据模型可以将复杂的现实世界要求反映到计算机数据库中的物理世界，这种反映是一个逐步变化的过程：由现实世界开始，经历信息世界而至计算机世界
<ol>
<li>世界
<ol>
<li>现实世界（Real World）</li>
<li>信息世界（Information World）:通过抽象对现实世界进行数据库级上的刻画所构成的逻辑模型叫信息世界，信息世界与数据库的具体模型有关</li>
<li>计算机世界（Computer World）：在信息世界的基础上致力于其在计算机物理结构上的描述，而形成的逻辑模型叫计算机世界</li>
</ol></li>
<li>数据模型：数据模型所描述的内容有三个部分：数据结构、数据操作、数据约束
<ol>
<li>数据结构：主要描述数据的类型、内容、性质以及数据间的联系</li>
<li>数据操纵：</li>
<li>数据约束：描述数据结构内数据间的语法、语义联系，它们之间的制约与依存关系，以及数据间的动态变化规则</li>
</ol></li>
<li>分类：
<ol>
<li>概念数据模型：是一种面向客观世界、面向用户的模型。概念数据模型是整个数据模型的基础，如E-R模型、扩充的E-R模型、面向对象模型以及谓词模型</li>
<li>逻辑数据模型：是一种面向数据库系统的模型。如，层次模型、网状模型、关系模型、面向对象模型</li>
<li>物理数据模型：面向计算机物理表示的模型</li>
</ol></li>
</ol></li>
<li>E-R模型（实体联系模型）
<ol>
<li>基本概念：
<ol>
<li>实体：现实世界中的事物可以抽象成为实体，实体是概念世界中的基本单位，它们是客观存在又相互区别的事物</li>
<li>属性：现实世界中的事物均有一些特点，这些特性可以用属性来表示</li>
<li>联系：现实世界中事物之间的关联称为联系
<ol>
<li>实体集间的联系
<ol>
<li>两个实体集之间的联系</li>
<li>多个实体集之间的联系</li>
<li>一个实体集内部的联系</li>
</ol></li>
<li>联系的个数
<ol>
<li>一对一的联系，简记为1:1</li>
<li>一对多的联系，简记为1:m或m：1</li>
<li>多对多的联系，简记为m:n</li>
</ol></li>
</ol></li>
<li>三个基本概念之间的联系
<ol>
<li>实体集（联系）与属性之间的连接关系
<ol>
<li>一个实体的所有属性取值组成一个值集叫元组（Tuple）</li>
<li>联系也可以附有属性</li>
</ol></li>
<li>实体（集）与联系
<ol>
<li>实体集之间可以通过联系建立连接关系，实体集之间无法建立直接关系，它只能通过联系才能建立连接关系</li>
</ol></li>
</ol></li>
<li>E-R模型的图示法：
<ol>
<li>实体集：矩形表示实体集，在矩形内部写上该实体集的名字</li>
<li>属性：用椭圆表示属性，在椭圆内部写上该属性的名称</li>
<li>联系表示法：用菱形表示联系，内写上联系名</li>
<li>实体集（联系）与属性之间连接关系：用连接两个图形之间的无向线段表示</li>
<li>实体集与联系间的连接关系：用连接两个图形的无向线段表示，还可以注明对应的函数关系</li>
</ol></li>
</ol></li>
</ol></li>
<li>层次模型：
<ol>
<li>基本结构：树形结构</li>
<li>特点：
<ol>
<li>每棵树有且只有一个无双亲结点，称为根（Root）</li>
<li>树中除根以外所有结点有且只有一个双亲</li>
</ol></li>
<li>缺点：
<ol>
<li>如果没有相应的双亲结点值就不能插入子女结点值</li>
<li>如果删除双亲结点值，则相应的子女结点值也被同时删除</li>
<li>查询子女结点必须通过双亲结点</li>
</ol></li>
</ol></li>
<li>网状模型：网状模型是一个不加任何限制的无向图
<ol>
<li>网状模型将通用的网状拓扑结构分成一些基本结构。一般采用的分解方法是将一个网络分成若干个二级树</li>
<li>基本结构简单二级树叫系（Set），系的基本单位是记录（Record），系有一个首记录（Owner Record），它相当于简单二级树的根，系同时有若干个成员记录（Member Record）</li>
</ol></li>
<li>关系模型
<ol>
<li>关系的数据结构：关系模式采用二维表来表示，简称表。二维表由表框架（Frame）及表的元组（Tuple）组成。<br/>
二维表满足以下性质：满足以下性质的二维表称为关系（Relation）
<ol>
<li>元组个数有限性</li>
<li>元组唯一性</li>
<li>元组的次数无关性</li>
<li>元组分量的原子性</li>
<li>属性名唯一性</li>
<li>属性的次序无关性</li>
<li>分量的值域的同一性</li>
</ol></li>
<li>关系操作
<ol>
<li>数据查询：分解为一个关系内的属性指定、一个关系内的元组选择、两个关系的合并三个基本操作以及一个查询操作</li>
<li>数据删除：一个关系内的元组选择与关系中元组删除两个基本操作</li>
<li>数据插入：只有一个基本操作</li>
<li>数据修改：不是基本操作，可分解为删除需修改的元组与插入修改后的元组两个更基本操作</li>
</ol></li>
<li>关系中的数据约束
<ol>
<li>实体完整性约束</li>
<li>参照完整性约束：不允许关系引用不存在的元组：即在关系中的外键要么是所关联关系中实际存在的元组，要么就为空值</li>
<li>用户定义的完整性约束</li>
</ol></li>
</ol></li>
<li>关系代数
<ol>
<li>关系模型的基本操作：
<ol>
<li>关系的属性指定</li>
<li>关系的元组的选择</li>
<li>两个关系的合并</li>
<li>关系的查询</li>
<li>关系元组的插入</li>
<li>关系元组的删除</li>
</ol></li>
<li>关系模型的基本运算
<ol>
<li>插入</li>
<li>删除</li>
<li>修改：删除+插入</li>
<li>查询：
<ol>
<li>投影运算：投影出一个列（属性集合）</li>
<li>选择运算：选择元组</li>
<li>笛卡尔积运算：两个关系的合并操作</li>
</ol></li>
</ol></li>
<li>关系代数中的扩充运算
<ol>
<li>交运算：</li>
<li>除运算：笛卡尔积的逆运算</li>
<li>连接与自然连接运算</li>
</ol></li>
<li>关系代数的应用实例</li>
</ol></li>
<li>数据库设计与管理
<ol>
<li>数据库设计概念：</li>
<li>设计方法
<ol>
<li>面向数据的方法：以信息需求为主兼顾处理需求（主流）</li>
<li>面向过程的方法：以处理需求为主，兼顾信息需求</li>
</ol></li>
<li>生命周期法：将整个数据库应用系统的开发分解成目标独立的若干阶段，需求分析阶段、概念设计阶段、逻辑设计阶段、物理设计阶段、编码阶段、测试阶段、运行阶段、进一步修改阶段。数据库设计中采用前四个阶段</li>
<li>需求分析
<ol>
<li>获取用户的如下要求：
<ol>
<li>信息要求</li>
<li>处理要求</li>
<li>安全性和完整性要求</li>
</ol></li>
<li>数据字典是进行详细的数据收集和数据分析所获的的主要结果</li>
</ol></li>
<li>数据库概念设计
<ol>
<li>概述
<ol>
<li>集中式模型设计法</li>
<li>视图集成模式设计法</li>
</ol></li>
<li>过程
<ol>
<li>选择局部应用</li>
<li>视图设计
<ol>
<li>自顶向下</li>
<li>自底向上</li>
<li>由内向外</li>
</ol></li>
<li>视图集成
<ol>
<li>注意：命名冲突、概念冲突、域冲突、约束冲突</li>
</ol></li>
</ol></li>
</ol></li>
<li>数据库的逻辑设计
<ol>
<li>从E-R图向关系模式转换
<ol>
<li>实体集与联系都可以表示成关系</li>
<li>属性转换为关系的属性</li>
<li>实体转换为元组</li>
</ol></li>
<li>逻辑模式规范化及调整、实现
<ol>
<li>规范化：设计不良的关系模式会有数据冗余、插入异常、删除异常及修改异常等问题，需要通过分解进行规范化
<ol>
<li>对于关系模式若其中的每个属性都已不能再分为简单项，则它属于第一范式模式（1NF）</li>
<li>如果某个关系模式R为第一范式并且R中每一个非主属性完全函数依赖于R的某个候选键，则称其为第二范式模式（2NF）（消除了非主属性对主键的部分依赖）</li>
<li>如果关系模式R是第二范式，并且每个非主属性都不传递依赖于R的候选键，则称R为第三范式模式（3NF）</li>
<li>更高级的是BCNF，要求所有属性都不传递依赖于关系的任何候选键，但是并不一定要做到，一般做到三就好了</li>
</ol></li>
<li>RDBMS
<ol>
<li>调整性能以减少连接运算</li>
<li>调整关系大小，使每个关系数量保持在合理水平，从而提高存取效率</li>
<li>尽量采用快照</li>
</ol></li>
</ol></li>
<li>关系视图设计：关系视图是在关系模式基础上所设计的直接面向操作用户的视图，它可以根据用户需求随时创建
<ol>
<li>提供数据逻辑独立性</li>
<li>能适应用户对数据的不同需求</li>
<li>有一定数据保密功能</li>
</ol></li>
</ol></li>
<li>数据库的物理设计
<ol>
<li>数据库管理
<ol>
<li>数据库建立
<ol>
<li>数据模式建立</li>
<li>数据加载</li>
</ol></li>
</ol></li>
<li>数据库的调整</li>
<li>数据库的重组</li>
<li>数据库安全性控制与完整性控制</li>
<li>数据库的故障较复</li>
<li>数据库监控</li>
</ol></li>
</ol></li>
</ol>

<h2 id="toc_2">数据结构与算法</h2>

<ol>
<li>算法基本特征：
<ol>
<li>可行性：每个步骤能够实现；结果能达到预期</li>
<li>确定性</li>
<li>有穷性</li>
<li>拥有足够多的情报</li>
</ol></li>
<li>算法设计基本方法
<ol>
<li>列举法</li>
<li>归纳法</li>
<li>递推</li>
<li>递归
<ol>
<li>自己调用自己的过程称为递归调用过程</li>
</ol></li>
<li>减半递推技术
<ol>
<li>二分法求方程实根</li>
</ol></li>
<li>回溯法</li>
</ol></li>
<li>算法的复杂程度
<ol>
<li>算法时间复杂度：算法的工作量与算法所执行的基本运算次数以及问题的规模有关，而有时算法所执行的基本运算次数与特定的输入有关
<ol>
<li>平均性态：各种特定输入下基本运算次数的加权平均数。A(n)</li>
<li>最坏情况复杂性：在规模为n时，算法所执行的基本运算的最大次数。W(n)。比A(n)更具有实用价值。</li>
</ol></li>
<li>算法的空间复杂度：执行这个算法所需要的内存空间</li>
</ol></li>
<li>数据结构
<ol>
<li>数据结构是指反应数据元素之间关系的数据元素集合的表示</li>
<li>数据处理：是指对数据集合中的各元素以各种方式进行运算，包括插入、删除、查找、更改等，也包括对数据元素进行分析</li>
<li>前后件关系时数据元素之间的一个基本关系，数据元素之间的任何关系都可以用前后件关系来描述</li>
</ol></li>
<li>数据的逻辑结构:
<ol>
<li>一个数据结构应该包括：
<ol>
<li>表示数据元素的信息</li>
<li>表示各元素之间的前后件关系，其中，数据元素之间的前后件关系是指它们的逻辑关系，与它们在计算机中的储存位置无关</li>
</ol></li>
<li>B=(D,R) data,relation</li>
</ol></li>
<li>数据的储存结构
<ol>
<li>数据的逻辑结构在计算机储存空间中的存放形式称为数据的储存结构</li>
<li>常用的储存结构：顺序、链接、索引</li>
</ol></li>
<li>线性结构与非线性结构
<ol>
<li>如果在一个数据结构中一个元素都没有，则称该数据结构为空的数据结构</li>
<li>线性结构（线性表）：
<ol>
<li>有且只有一个根节点</li>
<li>每一个结点最多有一个前件，也最多有一个后件</li>
<li>在一个线性结构中插入或删除任何一个结点后还应是线性结构</li>
</ol></li>
<li>非线性结构：不是线性就是非线性</li>
<li>一个空的数据结构是线性还是非线性根据具体情况确定，如果对该数据结构的运算是按线性结构规则处理的则属于线性结构，否则属于非线性结构。</li>
</ol></li>
<li>线性表及其顺序储存结构
<ol>
<li>线性表是由n个数据元素组成的一个有限序列，表中的每一个元素，除了第一个以外，有且只有一个前件，除了最后一个外，有且只有一个后件</li>
<li>矩阵也是一个线性表</li>
<li>复杂的线性表中，由若干数据项组成的数据元素称为记录，由多个记录构成的线性表又称为文件</li>
<li>线性表的顺序储存结构：
<ol>
<li>线性表中所有元素所占的储存空间是连续的</li>
<li>线性表中个数据元素在储存空间中是按逻辑顺序依次存放的</li>
</ol></li>
<li>顺序表的插入运算：效率低，可能发生“上溢”错误</li>
<li>顺序表的删除运算：效率低，可能发生“下溢”错误</li>
</ol></li>
<li>栈和队列
<ol>
<li>栈：限定在一端进行插入和删除的线性表
<ol>
<li>在顺序储存结构下，对栈的插入与删除时不需要移动表中其他元素的</li>
<li>允许插入与删除的一端称为栈顶，不允许插入和删除的一端称为栈底</li>
<li>先进后出，后进先出（FILO，LIFO），栈具有记忆功能</li>
<li>通常用指针top来指示栈顶的位置，用指针bottom指向栈底</li>
<li>在栈中插入一个元素称为入栈运算，删除一个元素称为退栈运算</li>
<li>栈的顺序储存及运算
<ol>
<li>入栈运算</li>
<li>退栈运算</li>
<li>读栈顶元素</li>
</ol></li>
</ol></li>
<li>队列：指允许在一端进行插入，而在另外一端进行删除的线性表
<ol>
<li>允许插入的一端称为队尾，通常用一个尾指针（rear）指向队尾元素；允许删除的一端称为排头（队头），通常用排头指针（front）指向排头元素的前一个位置。</li>
<li>先进先出，后进后出（FIFO，LILO）</li>
<li>在队尾插入一个元素称为入队运算，从排头删除一个元素称为退队运算</li>
<li>循环队列：在实际应用中，队列的顺序储存结构一般采用循环队列的形式。Front=rear时，队列要么为空，要么为满，所以要加一个标志s，s=0为空，1为非空</li>
</ol></li>
</ol></li>
<li>线性链表
<ol>
<li>链式储存方式中，要求每个结点有由两部分组成：一部分用于存放数据元素值，称为数据域，另一部分用于存放指针，称为指针域。其中指针用于指向该结点的前一个或后一个结点</li>
<li>线性表的链式存储方式称为线性链表：指针域用于指向下一个元素的存储序号</li>
<li>双向链表：一个左指针（Llink）指向前件结点，一个右指针（Rlink）指向后件结点</li>
<li>带链的栈：</li>
<li>带栈的队列</li>
<li>循环链表：增加一个表头结点，最后一个结点的指针域不为空，而是指向表头结点
<ol>
<li>只要指出表中任意结点位置，就可以从它出发访问到表中其他所有的结点，线性单链表做不到</li>
<li>由于设置表头结点，因此，在任何情况下，循环链表中至少有一个结点，使空表与非空表运算统一</li>
</ol></li>
</ol></li>
<li>树与二叉树
<ol>
<li>树中，每一个结点只有一个前件，称为父结点，每一个节点可以有多个后件，称为子结点，没有后件的结点称为叶子结点。一个结点所拥有的后件个数称为该结点的度，在树中，所以结点中最大的度称为树的度；在树中，所以结点的度之和再加一为树的结点数。树的最大层数称为树的深度</li>
<li>二叉树基本性质
<ol>
<li>性质一</li>
<li>性质二</li>
<li>性质三：在任意一颗二叉树中，度为零的结点总是比度为2的结点多一个</li>
<li>性质四</li>
</ol></li>
<li>满二叉树：每一层上的结点数都达到最大值</li>
<li>完全二叉树：除最后一层外，每一层上的结点数均达到最大值，在最后一层上只缺少右边的若干结点。
<ol>
<li>性质五</li>
<li>性质六</li>
</ol></li>
<li>二叉树存储结构：在计算机中，二叉树通常采用链式存储结构，对于满二叉树和完全二叉树来说，可以按层序进行顺序存储</li>
<li>二叉树的遍历：
<ol>
<li>前序遍历（DLR）：根结点、左子树、右子树</li>
<li>中序遍历（LDR）：左子树、根结点、右子树</li>
<li>后序遍历（LRD）：左子树、右子树、根结点</li>
<li>如果知道了前序序列和中序序列或者知道了中序序列和后序序列可以唯一地恢复该二叉树，但是如果知道了前序序列和后序序列，不能唯一地恢复该二叉树</li>
</ol></li>
</ol></li>
<li>查找技术：
<ol>
<li>顺序查找：对于大的线性表效率低，但是对于无序表和链表只能用顺序查找</li>
<li>二分法查找：只适用于顺序存储的有序表</li>
</ol></li>
<li>排序技术：
<ol>
<li>交换类排序方式：
<ol>
<li>冒泡排序：最坏-- n(n-1)/2</li>
<li>快速排序：最坏-- n(n-1)/2 一般比冒泡要好</li>
</ol></li>
<li>插入类排序：
<ol>
<li>简单插入排序：最坏--n（n-1）/2 效率与冒泡相同</li>
<li>希尔排序：最坏效率与所选取增量有关</li>
</ol></li>
<li>选择类排序：
<ol>
<li>简单选择排序法：最坏--n(n-1)/2</li>
<li>堆排序法：最坏-- nlog2n 对于较小规模不适用，对于较大规模线性表很有效</li>
</ol></li>
</ol></li>
</ol>

<h2 id="toc_3">软件工程基础</h2>

<ol>
<li>软件的定义及软件的特点：
<ol>
<li>程序是软件开发人员根据用户需求开发的、用程序设计语言描述的、适合计算机执行的指令序列</li>
<li>特点：
<ol>
<li>软件是一种逻辑实体，而不是物理实体，具有抽象性</li>
<li>软件的生产与硬件不同，没有明显的制作过程</li>
<li>软件在运行、使用期间不存在磨损、老化问题</li>
<li>软件的开发、运行对计算机系统具有依赖性</li>
<li>软件复杂性高，成本昂贵</li>
<li>软件开发涉及诸多社会因素</li>
</ol></li>
<li>分类：
<ol>
<li>应用软件：为解决特定领域的应用而开发的软件</li>
<li>系统软件：计算机管理自身资源、提高计算机使用效率并服务于其他程序的软件。如，操作系统，编译程序，汇编程序，网络软件，数据库管理系统</li>
<li>支撑软件（工具软件）：介于系统软件和应用软件之间，协助用户开发软件的工具箱软件</li>
</ol></li>
</ol></li>
<li>软件危机与软件工程
<ol>
<li>软件危机：泛指在计算机软件的开发和维护过程中所遇到的一系列严重问题</li>
<li>软件工程：将系统化的、规范的、可度量的方法应用于软件的开发、运行和维护的过程，即将工程化应用于软件中</li>
<li>软件工程三要素：方法、工具、过程</li>
</ol></li>
<li>软件过程与软件生命周期：
<ol>
<li>软件过程：软件过程就是把输入转化为一组彼此相关的资源和活动</li>
<li>软件生命周期：软件从提出、实现、使用、维护到停止使用退役的过程称为软件的生命周期。
<ol>
<li>可行性研究与计划制定</li>
<li>需求分析</li>
<li>软件设计</li>
<li>编码</li>
<li>软件测试</li>
<li>运行与维护</li>
</ol></li>
</ol></li>
<li>软件工程的目标与原则：
<ol>
<li>目标：在给定成本、进度的前提下，开发具有有效性、可靠性、可理解性、可维护性、可重用性、可适应性、可移植性、可追踪性和可操作性且满足用户需求的产品</li>
<li>研究内容：
<ol>
<li>软件开发技术：软件开发方法学、开发过程、开发工具、软件工程环境</li>
<li>软件工程管理：软件管理学、软件工程经济学、软件心理学</li>
<li>软件工程的原则：
<ol>
<li>抽象</li>
<li>信息隐蔽</li>
<li>模块化</li>
<li>局部化</li>
<li>确定性</li>
<li>一致性</li>
<li>完备性</li>
<li>可验证性</li>
</ol></li>
</ol></li>
</ol></li>
<li>结构化分析方法
<ol>
<li>软件开发方法：分析方法、设计方法、程序设计方法</li>
<li>结构化方法：结构化分析方法、结构化设计方法、结构化编程方法</li>
</ol></li>
<li>需求分析与需求分析方法
<ol>
<li>需求分析：用户对目标软件系统在功能、行为、性能、设计约束等方面的期望。需求分析的任务是发现需求、求精、建模和定义需求的过程。</li>
<li>需求分析方法：
<ol>
<li>结构化分析方法：面向数据流的结构化分析方法（SA）、面向数据结构的Jackson方法（JSD）、面向数据结构的结构化数据系统开发方法（DSSD）</li>
<li>面向对象的分析方法（OOA）：</li>
</ol></li>
</ol></li>
<li>结构化分析方法：
<ol>
<li>实质：着眼于数据流，自顶向下，逐层分解，建立系统的处理流程，以数据流图和数据字典为主要工具，建立系统的逻辑模型</li>
<li>工具：
<ol>
<li>数据流图（DFD）：
<ol>
<li>元素：加工、数据流、数据源、数据的源点和终点</li>
<li>步骤：由外向里，自顶向下，逐层分解。</li>
</ol></li>
<li>数据字典（DD）：对所有与系统相关的数据元素的一个有组织的列表，以及精确、严格定义。</li>
<li>判定树</li>
<li>判定表</li>
</ol></li>
</ol></li>
<li>软件需求规格说明书
<ol>
<li>内容：软件的目标，功能需求、性能需求、外部接口、属性及约束条件</li>
<li>特点
<ol>
<li>正确性</li>
<li>无歧义性</li>
<li>完整性</li>
<li>可验证性</li>
<li>一致性</li>
<li>可理解性</li>
<li>可修改性</li>
<li>可追踪性</li>
</ol></li>
</ol></li>
<li>结构化设计方法
<ol>
<li>软件设计基本概念
<ol>
<li>目标：用比较抽象概括的方式确定目标系统如何完成预定的任务，即软件设计是确定系统的物理模型</li>
<li>包括：结构设计、数据设计、接口设计、过程设计</li>
<li>一般过程：软件设计是一个迭代过程，先进行高层次的结构设计，后进行低层次的过程设计，穿插进行数据设计和接口设计</li>
<li>基本原理：
<ol>
<li>抽象</li>
<li>逐步求精和模块化</li>
<li>信息隐蔽和局部化</li>
<li>模块独立性（高内聚、低耦合）</li>
</ol></li>
<li>结构化设计方法：采取最佳的可能方法设计系统的各个组成部分以及各成分之间的内部联系的技术</li>
</ol></li>
<li>概要设计
<ol>
<li>设计软件系统结构</li>
<li>数据结构及数据库设计</li>
<li>编写概要设计文档</li>
<li>概要设计文档评审</li>
<li>常用软件结构设计工具是结构图（SC）
<ol>
<li>构成：一般模块、数据信息、控制信息</li>
<li>四种模块：传入、传出、变化、协调</li>
<li>术语：
<ol>
<li>深度：表示控制的层数</li>
<li>宽度：整体控制跨度</li>
<li>扇入：调用一个给定模块的个数</li>
<li>扇出：一个模块调用的其他模块数</li>
<li>原子模块：树中位于叶子结点的模块</li>
</ol></li>
</ol></li>
<li>面向数据流的结构化设计方法
<ol>
<li>数据流类型
<ol>
<li>变换型</li>
<li>实物型</li>
</ol></li>
<li>面向数据流设计方法的实施要点与设计过程
<ol>
<li>分析、确认数据流图的类型，区分是事物型还是变换型</li>
<li>说明数据流的边界</li>
<li>把数据流图映射为程序结构</li>
<li>根据设计准则对产生的结构进行细化和求精</li>
</ol></li>
</ol></li>
<li>设计的准则
<ol>
<li>提高模块独立性</li>
<li>模块规模适中</li>
<li>深度、宽度、扇出和扇入适当</li>
<li>使模块的作用域在该模块的控制域内</li>
<li>应减少模块的接口和界面的复杂性</li>
<li>设计成单入口、单出口的模块</li>
<li>设计功能可预测的模块</li>
</ol></li>
<li>详细设计
<ol>
<li>确定模块内部的详细执行过程，包括局部数据组织、控制流、每一步具体处理要求和各种实现细节等</li>
<li>设计工具
<ol>
<li>图形工具：程序流程图（PFD）、N-S图、PAD图、HIOP图</li>
<li>表格工具：判定表</li>
<li>语言工具：PDL</li>
</ol></li>
</ol></li>
</ol></li>
</ol></li>
<li>软件测试
<ol>
<li>目的和定义
<ol>
<li>定义：
<ol>
<li>在规定条件下运行系统或构件的过程；在此过程中观察和记录结果，并对系统或构件的某些方面给出评价</li>
<li>软件项目的过程：检测现有状况或所需状况的不同（bug），并评估软件的特性</li>
</ol></li>
<li>目的：
<ol>
<li>软件测试是为了发现错误而执行程序的过程</li>
<li>一个好的测试用例是指很有可能找到迄今为止尚未发现的错误的用例</li>
<li>一个成功的测试是发现了至今尚未发现的错误的测试</li>
</ol></li>
</ol></li>
<li>软件测试的准则
<ol>
<li>所有测试都应追溯到需求</li>
<li>严格执行测试计划，排除测试的随意性</li>
<li>充分主语测试中的群集现象</li>
<li>程序员应该避免检查自己的程序</li>
<li>穷举测试不可能</li>
<li>妥善保存测试计划、测试用例、出错统计和最终分析报告，为维护提供方便</li>
</ol></li>
<li>软件测试方法与技术综述
<ol>
<li>静态测试与动态测试
<ol>
<li>静态测试：变量检查、命名和类型审查、程序逻辑审查、程序语法审查和程序结构检查
<ol>
<li>代码检查包括：代码审查、代码走查、桌面检查、静态分析</li>
</ol></li>
<li>动态测试：设计高效合理的测试用例是动态测试的关键</li>
</ol></li>
<li>白盒测试方法与测试用例设计
<ol>
<li>白盒测试把测试对象看作打开的盒子，允许测试人员利用程序内部的逻辑机构及有关信息来设计或选择测试用例</li>
<li>基本原则：保证所测模块中每一独立路径至少执行一次；保证所测模块所有判断的每一分枝至少执行一次；保证所测模块每一循环都在边界条件和一般条件下至少各执行一次；验证所有内部数据结构的有效性</li>
<li>分类：
<ol>
<li>等价类划分法：
<ol>
<li>有效等价类：合理、有意义的输入数据构成的集合</li>
<li>无效等价类：不合理、无意义的输入数据构成的集合</li>
</ol></li>
<li>边界值分析法：一般多用边界值分析法来补充等价类划分法</li>
<li>错误推测法</li>
</ol></li>
</ol></li>
</ol></li>
<li>软件测试的粗略
<ol>
<li>单元测试：依据详细设计说明书和源程序，采用静态分析和动态测试。对动态测试通常以白盒测试为主，黑盒测试为辅。目的是发现各模块内部可能存在的各种错误
<ol>
<li>测试内容：模块接口测试、局部数据结构测试、重要执行路径检查、出错处理测试、影响以上各点及其他相关点的边界条件测试</li>
</ol></li>
<li>集成测试：依据概要设计说明书，目的是发现与接口有关的错误
<ol>
<li>非增量方式：将测试好的每一个软件单元一次性组装在一起再进行整体测试</li>
<li>增量方式：将已经测试好的模块逐步组装成较大系统，在组装过程中边接边测，以发现连接过程中产生的问题
<ol>
<li>自顶向下：较早显示整个程序轮廓，较早验证主要的控制和判断点。但是当测试上层模块时使用的桩模块较多，很难摸清真实模块的全部功能，导致部分测试推迟</li>
<li>自底向上：实际测试用例比较容易，但是在早期不能显示出程序的轮廓</li>
<li>自顶向下和自底向上相结合</li>
</ol></li>
</ol></li>
<li>确认测试：验证软件的功能和性能及其他特性是否满足了需求规格说明中确定的各种需求，以及软件配置是否完全，正确。黑盒测试</li>
<li>系统测试：将通过确认测试的软件，作为整个基于计算机系统的一个元素，与计算机硬件、外设、支持软件、数据和人员等其他元素组合在一起，在实际运行环境下对计算机系统进行一系列的集成测试和确认测试</li>
</ol></li>
</ol></li>
<li>程序的调试 
<ol>
<li>目的：诊断和改正程序中的错误（软件测试是尽可能多地发现软件中的错误，贯穿整个软件的生命周期，调试主要发生在开发阶段）</li>
<li>基本步骤
<ol>
<li>错误定位：占据绝大部分工作量</li>
<li>修改设计和代码，以排除错误</li>
<li>进行回归测试防止引进新的错误</li>
</ol></li>
<li>原则：
<ol>
<li>确定错误原则
<ol>
<li>分析思考与错误征兆有关的信息</li>
<li>避开死胡同</li>
<li>只把调试工具当辅助手段来用</li>
<li>避免使用试探法，最多只能当作最后手段</li>
</ol></li>
<li>修改错误的原则
<ol>
<li>在出现错误的地方，有可能还有别的错误</li>
<li>不要只修改了错误的征兆或表现，而没有修改错误本身</li>
<li>注意修改一个错误的同时可能引进一个新的错误</li>
<li>修改错误的过程将迫使人们暂时回到程序设计阶段</li>
<li>修改源代码，不要改变目标代码</li>
</ol></li>
</ol></li>
<li>软件调试方法：静态调试为主，动态调试为辅
<ol>
<li>强行排错法：设置断点，程序暂停，观察程序状态，继续运行程序</li>
<li>回溯法：适用于小规模程序排错</li>
<li>原因排除法：通过演绎和归纳以及二分法</li>
</ol></li>
</ol></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SAS DATA步之全揭秘]]></title>
    <link href="https://cubetian.github.io/15685969611776.html"/>
    <updated>2019-09-16T09:22:41+08:00</updated>
    <id>https://cubetian.github.io/15685969611776.html</id>
    <content type="html"><![CDATA[
<p>一些概念</p>

<ul>
<li>程序数据向量（PDV）</li>
<li>SAS自动变量名及其使用</li>
<li>理解DATA步内部处理过程</li>
<li>代码编译期间发生的事情</li>
<li>程序执行期间实际发生了什么</li>
<li>如何获取和存储变量属性</li>
</ul>

<p>DATA时建立SAS数据集的主要方法之一。一些涉及数据处理和创建数据集的任务可能只能通过DATA步才能解决<br/>
DATA步分编译和执行两个阶段，PDV贯穿SAS编译和执行的两个阶段，决定了信息在DATA步中的存储及变化</p>

<p>编译阶段包括：</p>

<ul>
<li>编译SAS语句，包括检查语法</li>
<li>创建一个输入缓存区（input buffer）（如果需要读入原始数据文件）、一个PDV和描述性信息</li>
</ul>

<p>执行阶段包括：</p>

<ul>
<li>计算DATA步迭代的次数（从DATA语句开始）</li>
<li>将PDV中所有变量设成缺失值并初始化自动变量</li>
<li>读取输入观测（从原始文件或SAS数据集）</li>
<li>执行附加的处理或计算语句</li>
<li>将一条数据记录写入输出数据集并返回到DATA步语句</li>
</ul>

<p>PDV贯穿编译的执行阶段：</p>

<ul>
<li>PDV是内存的一个临时逻辑区域，SAS建立数据集时，每条观察值只有一次机会用的PDV</li>
<li>包含所有变量的当前值</li>
<li>包含两个自动变量：_N_和_ERROR_</li>
</ul>

<p>DATA步<br/>
一个DATA步包含SAS语言的一组语句，这些语句具有以下功能</p>

<ul>
<li>从外部文件读入数据</li>
<li>将数据写入外部文件</li>
<li>读入SAS数据集和SAS视图</li>
<li>创建SAS数据集和SAS视图<br/>
一旦数据可以以SAS数据集的形式访问，就可以通过SAS过程步来分析数据和写报告</li>
</ul>

<p>可以运用DATA步：</p>

<ul>
<li>创建SAS数据集（SAS数据集或SAS视图）</li>
<li>根据包含原始数据（外部文件）和文件创建SAS数据集</li>
<li>通过提取子集、合并、修改和更新已经存在数据集的方式来创建新的数据集</li>
<li>分析、处理或展现数据</li>
<li>为新变量赋值（在有公式计算的情况下）</li>
<li>撰写报告或将文件写入磁盘或磁带</li>
<li>信息检索</li>
<li>文件管理<br/>
DATA步以‘DATA’语句开始（即显示的表明数据步的开始），以‘RUN’语句结束，在结束时会编译或执行RUN语句。在数据步最后一个观察值读取前，‘RUN’的功能都是以非显示的形式执行RETURN功能，去继续循环的操作。
<img src="media/15685969611776/15687662911534.png" alt=""/>
编译阶段<br/>
如上所示，DATA步的第一个阶段就为编译阶段。在编译阶段SAS的任务如下：</li>
<li>自动将SAS语句编译成将会在后面执行的机器语言</li>
<li>确定每个变量的类型和长度</li>
<li>确定变量是否有必要进行类型转换</li>
<li>如果有INPUT语句，为外部文件新建读取内存缓存区</li>
<li>创建PDV（Program Data Vector）</li>
<li>创建数据集和变量属性的描述性信息</li>
<li>处理语句，该项任务仅限于编译阶段；这为编译器如何新建变量提供信息；事实上，他们决定了如何在PDV内建立变量及信息；这些信息包括：DROP；KEEP；RENAME；RETAIN；RHERE；LABEL；LENGTH；FORMAT；ARRAY；BY；ATTRIB</li>
<li>创建自动变量：包括_N_,_ERROR_,RND=,IN=,FIRST,LAST,POINT=</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LATEX 定理、命题环境]]></title>
    <link href="https://cubetian.github.io/15686818191570.html"/>
    <updated>2019-09-17T08:56:59+08:00</updated>
    <id>https://cubetian.github.io/15686818191570.html</id>
    <content type="html"><![CDATA[
<p>在LaTex中需要有关定理、公理、命题、引理、定义等时，常用如下命令</p>

<ul>
<li><strong>\newtheorem</strong>{定理环境名}{标题}[主计数器名] </li>
<li><strong>\newtheorem</strong>{theorem}{Theorem}[Chapter]</li>
</ul>

<p>意思就是定义一个以Theorem为标题的theorem环境,计数以章节数为主.</p>

<p> </p>

<p><strong>\begin{theorem}[均值不等式]</strong></p>

<p>设\(A,B\)是两个实数, 则\(2AB\leq 2 A^2+B^2\).</p>

<p><strong>\end{theorem}</strong></p>

<p>如果需要输出中文,使用定义theorem如下</p>

<p><strong>\newtheorem{theorem}{\hspace{2em}定理}[chaptet]</strong></p>

<p>另外在{\hspace{2em}定理}中还可以输入更改字体的命令来改变定理的字体</p>

<p><strong>其他中文模式：</strong></p>

<ul>
<li><strong>\newtheorem{Definition}{\hspace{2em}定义}[chapter]</strong></li>
<li><strong>\newtheorem{theorem}{\hspace{2em}定理}[chapter]</strong></li>
<li><strong>\newtheorem{lemma}{\hspace{2em}引理}[chapter]</strong></li>
<li><strong>\newtheorem{Proof}{证明}[chapter]</strong></li>
</ul>

<p>前面提到的定理、公理、命题、引理、定义的一套命令可以用这个</p>

<p>% Theorem style</p>

<ul>
<li>\newtheoremstyle{mystyle}{3pt}{3pt}{\kaishu}{0cm}{\heiti2 }{}{1em}{}  \theoremstyle{mystyle}</li>
<li>\newtheorem{definition}{\hspace{2em}定义}[chapter] % </li>
<li>没有章, 只有节, 把上面的[chapter]改成[section] </li>
</ul>

<p><strong>文章中可以直接使用的范例：</strong></p>

<p><strong>\newtheorem{theorem}[definition]{\hspace{2em}定理} </strong></p>

<p><strong>\newtheorem{axiom}[definition]{\hspace{2em}公理} </strong></p>

<p><strong>\newtheorem{lemma}[definition]{\hspace{2em}引理} </strong></p>

<p><strong>\newtheorem{proposition}[definition]{\hspace{2em}命题} </strong></p>

<p><strong>\newtheorem{corollary}[definition]{\hspace{2em}推论} </strong></p>

<p><strong> \newtheorem{remark}{\hspace{2em}注}[chapter]</strong></p>

<p> </p>

<hr/>

<p> </p>

<p><strong>Latex-定理定义的排版</strong></p>

<p>\newtheorem{thm}{Theorem}[section]</p>

<p>\newtheorem{prop}{Proposition}[section]</p>

<p>以上定理和命题分别计数，如果命题也用定理的计数器，可以这样定义：</p>

<p>\newtheorem{prop}[thm]{Proposition}</p>

<p>引用：</p>

<p>\begin{thm}[附加标题,如定理名称，作者]</p>

<p>文本</p>

<p>\end{thm}</p>

<p>较短的证明可以用</p>

<p>\begin{proof}[标题]</p>

<p>证明内容。</p>

<p>\end{proof}</p>

<p> </p>

<p>如果有[标题]选项，则显示这个标题(斜体)，否则自动打印斜体的Proof，并在证明结束时自动生成证毕符号口。</p>

<p>如果使用\proof命令，则需要在结束时手动加上结束命令\qed。</p>

<p>当然你可以重定义证毕符号，例如：</p>

<p>\renewcommand*{\qedsymbol}{[证毕]}</p>

<p>\begin{proof}[证:]</p>

<p>证明正文。</p>

<p>\end{proof}</p>

<p>注意：</p>

<p>\begin{proof}...\end{proof}&quot; role=&quot;presentation&quot; style=&quot;margin: 0px; padding: 0px; display: inline; font-weight: normal; line-height: normal; font-size: 14px; text-align: left; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; position: relative;&quot;&gt;<br/>
\begin{proof}...\end{proof}</p>

<p>环境需要\usepackage{amsthm}宏包的支持</p>

<p> </p>

<h2 id="toc_0"> </h2>

<h2 id="toc_1">首先你要先使用宏包 ntheorem</h2>

<h2 id="toc_2"> </h2>

<h2 id="toc_3">\usepackage[amsmath,thmmarks]{ntheorem}</h2>

<h2 id="toc_4">% 定理类环境宏包，其中 amsmath 选项</h2>

<p>% 用来兼容 AMS LaTeX 的宏包</p>

<h2 id="toc_5"> %=== 配合上面的ntheorem宏包产生各种定理结构,重定义一些</h2>

<h2 id="toc_6">%正文相关标题 ===</h2>

<p>\theoremstyle{plain}<br/>
\theoremheaderfont{\normalfont\rmfamily\CJKfamily{hei}}<br/>
\theorembodyfont{\normalfont\rm\CJKfamily{kai}} \theoremindent0em<br/>
\theoremseparator{\hspace{1em}} \theoremnumbering{arabic}<br/>
%\theoremsymbol{}          %定理结束时自动添加的标志</p>

<p> </p>

<p><strong>\newtheorem{theorem}{Theorem}<br/>
\newtheorem{corollary}{Corollary}<br/>
......<br/>
\begin{theorem}<br/>
......<br/>
\end{theorem}<br/>
......</strong></p>

<p><strong>\begin{corollary}<br/>
......<br/>
\end{corollary}</strong></p>

<p>这样的输出结果就是各自编号的定理和推论了，定义、命题等等也类似可以这么使用。如果你希望定理和推论一起编号，前面可以改为这样（意思是corollary也使用theorem的编号）：</p>

<p><strong>\newtheorem{theorem}{Theorem}<br/>
\newtheorem{corollary}[theorem]{Corollary}</strong></p>

<p>最后，如果你希望使用Theorem 1.4.2这样的编号，可以这么使用：</p>

<p><strong>\newtheorem{theorem}{Theorem}[subsection] \newtheorem{corollary}[theorem]{Corollary}</strong></p>

<p>前面的subsection改为section将输出Theorem 4.2这样的编号。</p>

<p> </p>

<p><strong>\newtheorem{theorem}{Theorem}[subsection] \newtheorem{corollary}[theorem]{Corollary}</strong></p>

<p>前面的subsection改为section将输出Theorem 4.2这样的编号。</p>

<p>如何让定理，推理等用同一计数器：</p>

<p>\newtheorem{thm}{Theorem}[section] %如果不采用章节号做前缀，则不用[section]<br/>
\newtheorem{defn}[thm]{Definition} %这句定义使得defn环境和thm共享编号<br/>
\newtheorem{lem}[thm]{Lemma} %这句定义使得lem环境和thm共享编号</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[赛前感想]]></title>
    <link href="https://cubetian.github.io/15682182289509.html"/>
    <updated>2019-09-12T00:10:28+08:00</updated>
    <id>https://cubetian.github.io/15682182289509.html</id>
    <content type="html"><![CDATA[
<p>现在是12:10，醒来后的晚上2019年全国大学生数学建模竞赛就要开始了，赛前就发生了很多事情，我的电脑因为一个模块的问题被我搞来搞去，python出现了很大问题，同伴的电脑因为一些硬件问题，不得不借用其他同学的电脑，所以需要重新安装许多东西，也是刚刚，我才结束完两个电脑的准备工作。<br/>
现在的心情当然是非常激动，也非常疲惫，这是大三的一次建模竞赛，也几乎是我能够获得国家级奖项的唯一机会，我一定要把握这次机会。明天还有两门十分重要的课程，如果落下来，也势必对我这学期的学习会产生很大影响。<br/>
不管那么多了，还是先睡觉了💤</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[地图相关]]></title>
    <link href="https://cubetian.github.io/15682069194444.html"/>
    <updated>2019-09-11T21:01:59+08:00</updated>
    <id>https://cubetian.github.io/15682069194444.html</id>
    <content type="html"><![CDATA[
<p>在描述数据时，如果有一张热力地图，将是一件非常棒的事情，在这里我在尝试用python制作地图</p>

<h2 id="toc_0">pyecharts</h2>

<p>pyecharts 将不再自带地图 js 文件。如用户需要用到地图图表，可自行安装对应的地图文件包。<br/>
全球国家地图: echarts-countries-pypkg (1.9MB): 世界地图和 213 个国家，包括中国地图<br/>
中国省级地图: echarts-china-provinces-pypkg (730KB)：23 个省，5 个自治区<br/>
中国市级地图: echarts-china-cities-pypkg (3.8MB)：370 个中国城市<br/>
中国县区级地图: echarts-china-counties-pypkg (4.1MB)：2882 个中国县·区<br/>
中国区域地图: echarts-china-misc-pypkg (148KB)：11 个中国区域地图，比如华南、华北。</p>

<pre><code class="language-text">如果提示缺少这个就安装一下
pip  install pyecharts_snapshot
pip install echarts-countries-pypkg
pip install echarts-china-provinces-pypkg
pip install echarts-china-cities-pypkg
pip install echarts-china-counties-pypkg
pip install echarts-china-misc-pypkg
</code></pre>

<h2 id="toc_1">Basemap</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[itertools 模块]]></title>
    <link href="https://cubetian.github.io/15681237931017.html"/>
    <updated>2019-09-10T21:56:33+08:00</updated>
    <id>https://cubetian.github.io/15681237931017.html</id>
    <content type="html"><![CDATA[
<p>在解决优化问题的过程中，经常需要遍历所有的情况，不仅需要考虑内存的问题，所需要迭代内容的生成也是一件很麻烦的事情，我曾经尝试过网格生成等方法，效果并不理想，十分复杂，直到我发现了它<br/>
原教程地址：<a href="http://funhacks.net/2017/02/13/itertools/">高效的 itertools 模块</a><br/>
itertools 是python的一个很小的模块，是python标准库中的，不需要另外安装<br/>
首先介绍迭代器的三种类型</p>

<ul>
<li>无限迭代器：生成一个无限序列，比如自然数序列 <code>1, 2, 3, 4, ...</code>；</li>
<li>有限迭代器：接收一个或多个序列（sequence）作为参数，进行组合、分组和过滤等；</li>
<li>组合生成器：序列的排列、组合，求序列的笛卡儿积等；</li>
</ul>

<h2 id="toc_0">无限迭代器</h2>

<p>itertools 模块提供了三个函数（事实上，它们是类）用于生成一个无限序列迭代器：</p>

<ul>
<li><p>count(firstval=0, step=1)</p>
<p>创建一个从 firstval (默认值为 0) 开始，以 step (默认值为 1) 为步长的的无限整数迭代器</p></li>
<li><p>cycle(iterable)</p>
<p>对 iterable 中的元素反复执行循环，返回迭代器</p></li>
<li><p>repeat(object [,times]</p>
<p>反复生成 object，如果给定 times，则重复次数为 times，否则为无限</p></li>
</ul>

<p>下面，让我们看看一些例子。</p>

<h3 id="toc_1">count</h3>

<p>count() 接收两个参数，第一个参数指定开始值，默认为0，第二个参数指定步长，默认为1:</p>

<pre><code class="language-text">&gt;&gt;&gt; import itertools
&gt;&gt;&gt;
&gt;&gt;&gt; nums = itertools.count()
&gt;&gt;&gt; for i in nums:
...     if i &gt; 6:
...         break
...     print i
...
0
1
2
3
4
5
6
&gt;&gt;&gt; nums = itertools.count(10, 2)    # 指定开始值和步长
&gt;&gt;&gt; for i in nums:
...     if i &gt; 20:
...         break
...     print i
...
10
12
14
16
18
20
</code></pre>

<h3 id="toc_2">cycle</h3>

<p>cycle() 用于对iterable中的元素反复执行循环：</p>

<pre><code class="language-text">&gt;&gt;&gt; import itertools
&gt;&gt;&gt;
&gt;&gt;&gt; cycle_strings = itertools.cycle(&#39;ABC&#39;)
&gt;&gt;&gt; i = 1
&gt;&gt;&gt; for string in cycle_strings:
...     if i == 10:
...         break
...     print i, string
...     i += 1
...
1 A
2 B
3 C
4 A
5 B
6 C
7 A
8 B
9 C
</code></pre>

<h3 id="toc_3">repeat</h3>

<p>repeat() 用于反复生成一个object：</p>

<pre><code class="language-text">&gt;&gt;&gt; import itertools
&gt;&gt;&gt;
&gt;&gt;&gt; for item in itertools.repeat(&#39;hello world&#39;, 3):
...     print item
...
hello world
hello world
hello world
&gt;&gt;&gt;
&gt;&gt;&gt; for item in itertools.repeat([1, 2, 3, 4], 3):
...     print item
...
[1, 2, 3, 4]
[1, 2, 3, 4]
[1, 2, 3, 4]
</code></pre>

<h2 id="toc_4">有限迭代器</h2>

<p>itertools 模块提供了多个函数（类），接收一个或多个迭代对象作为参数，对它们进行组合、分组和过滤等：</p>

<ul>
<li>chain() 连接</li>
<li>compress()</li>
<li>dropwhile()</li>
<li>groupby()</li>
<li>ifilter()</li>
<li>ifilterfalse()</li>
<li>islice()</li>
<li>imap()</li>
<li>starmap()</li>
<li>tee()</li>
<li>takewhile()</li>
<li>izip()</li>
<li>izip_longest()</li>
</ul>

<h2 id="toc_5">组合生成器</h2>

<p>itertools 模块还提供了多个组合生成器函数，用于求序列的排列、组合等：</p>

<ul>
<li>product</li>
<li>permutations</li>
<li>combinations</li>
<li>combinations_with_replacement</li>
</ul>

<h3 id="toc_6">product</h3>

<p>product 用于求多个可迭代对象的笛卡尔积，它跟嵌套的for循环等价，它的一般使用形式如下：</p>

<pre><code class="language-text">product(iter1, iter2, ... iterN, [repeat=1])
</code></pre>

<p>其中，repeat是一个关键字参数，用于指定重复生成序列的次数，</p>

<pre><code class="language-text">&gt;&gt;&gt; from itertools import product
&gt;&gt;&gt;
&gt;&gt;&gt; for item in product(&#39;ABCD&#39;, &#39;xy&#39;):
...     print item
...
(&#39;A&#39;, &#39;x&#39;)
(&#39;A&#39;, &#39;y&#39;)
(&#39;B&#39;, &#39;x&#39;)
(&#39;B&#39;, &#39;y&#39;)
(&#39;C&#39;, &#39;x&#39;)
(&#39;C&#39;, &#39;y&#39;)
(&#39;D&#39;, &#39;x&#39;)
(&#39;D&#39;, &#39;y&#39;)
&gt;&gt;&gt;
&gt;&gt;&gt; list(product(&#39;ab&#39;, range(3)))
[(&#39;a&#39;, 0), (&#39;a&#39;, 1), (&#39;a&#39;, 2), (&#39;b&#39;, 0), (&#39;b&#39;, 1), (&#39;b&#39;, 2)]
&gt;&gt;&gt;
&gt;&gt;&gt; list(product((0,1), (0,1), (0,1)))
[(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1)]
&gt;&gt;&gt;
&gt;&gt;&gt; list(product(&#39;ABC&#39;, repeat=2))
[(&#39;A&#39;, &#39;A&#39;), (&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;A&#39;), (&#39;B&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;C&#39;, &#39;A&#39;), (&#39;C&#39;, &#39;B&#39;), (&#39;C&#39;, &#39;C&#39;)]
&gt;&gt;&gt;
</code></pre>

<h3 id="toc_7">permutation</h3>

<p>permutation 用于生成一个排列，它的一般使用形式如下：</p>

<pre><code class="language-text">permutations(iterable[, r])
</code></pre>

<p>其中，r 指定生成排列的元素的长度，如果不指定，则默认为可迭代对象的元素长度。</p>

<pre><code class="language-text">&gt;&gt;&gt; from itertools import permutations
&gt;&gt;&gt;
&gt;&gt;&gt; permutations(&#39;ABC&#39;, 2)
&lt;itertools.permutations object at 0x1074d9c50&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; list(permutations(&#39;ABC&#39;, 2))
[(&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;A&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;C&#39;, &#39;A&#39;), (&#39;C&#39;, &#39;B&#39;)]
&gt;&gt;&gt;
&gt;&gt;&gt; list(permutations(&#39;ABC&#39;))
[(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;), (&#39;A&#39;, &#39;C&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;C&#39;, &#39;A&#39;), (&#39;C&#39;, &#39;A&#39;, &#39;B&#39;), (&#39;C&#39;, &#39;B&#39;, &#39;A&#39;)]
&gt;&gt;&gt;
</code></pre>

<h3 id="toc_8">combination</h3>

<p>combinations(不放回) 用于求序列的组合，它的使用形式如下：</p>

<pre><code class="language-text">combinations(iterable, r)
</code></pre>

<p>其中，r指定生成组合的元素的长度</p>

<pre><code class="language-text">&gt;&gt;&gt; from itertools import combinations
&gt;&gt;&gt;
&gt;&gt;&gt; list(combinations(&#39;ABC&#39;, 2))
[(&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;C&#39;)]
</code></pre>

<p>combinations_with_replacement（放回抽取） 和 combinations 类似，但它生成的组合包含自身元素。</p>

<pre><code class="language-text">&gt;&gt;&gt; from itertools import combinations_with_replacement
&gt;&gt;&gt;
&gt;&gt;&gt; list(combinations_with_replacement(&#39;ABC&#39;, 2))
[(&#39;A&#39;, &#39;A&#39;), (&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;C&#39;, &#39;C&#39;)]
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[蚁群优化算法学习笔记]]></title>
    <link href="https://cubetian.github.io/15681180752987.html"/>
    <updated>2019-09-10T20:21:15+08:00</updated>
    <id>https://cubetian.github.io/15681180752987.html</id>
    <content type="html"><![CDATA[
<p>本人阅读《蚁群优化算法》-马良等过程中的笔记<br/>
前五章的目录</p>

<ol>
<li>引论
<ol>
<li>组合优化与计算复杂性</li>
<li>来自自然界的几类优化方法</li>
</ol></li>
<li>蚁群算法原理
<ol>
<li>基本思想</li>
<li>研究概况</li>
</ol></li>
<li>标准的TSP的蚁群算法
<ol>
<li>TSP概述</li>
<li>经典方法</li>
<li>遗传算法与模拟退火</li>
<li>蚁群算法</li>
<li>元胞蚁群算法及其收敛性</li>
</ol></li>
<li>扩展旅行商问题的蚁群算法
<ol>
<li>瓶颈TSP及其求解</li>
<li>最小比率TSP及其求解</li>
<li>时间约束TSP及其求解</li>
<li>多目标TSP及其求解</li>
</ol></li>
<li>车辆路径问题的蚁群算法
<ol>
<li>VRP概述</li>
<li>CVRP及其求解</li>
<li>多目标VRP及其求解</li>
<li>VRPTW及其求解</li>
<li>VRPSTW及其求解</li>
<li>FVRP及其求解<br/>
看完目录前五章，首先有好多英文缩写看不明白，接着看</li>
</ol></li>
</ol>

<h2 id="toc_0">第一章 引论</h2>

<p>1.1 组合优化与计算复杂性<br/>
最优化分连续变量与离散变量，离散变量的问题往往称为组合优化<br/>
局部搜索法是基于贪婪思想，利用领域函数进行搜索的，局部搜索法可能落入局部最优点，或由于步长和初始点选择不好而错过最优点。<br/>
依据一定概率，对于步长问题，可以采用变步长方法，在接近最优点附近，采取某种策略改变步长<br/>
对于初始点问题，可以采用随机生成的一些初始点，从每个初始点出发进行搜索，找到各自的最优解，再从这些最优解中选择一个最好的结果</p>

<p>典型组合优化难题<br/>
    1. 旅行商问题（TSP）：所有可能的路线最多有（n-1）!/2 条<br/>
    2. 图着色问题（GCP）：记图的最大顶点读书为\(\Delta\) ，则图的最小着色数以\(\Delta + 1\)为上界<br/>
    3. 工件排序问题（JSP）：NP难题（NP-hard）<br/>
    4. 二次分配问题（QAP）：目标函数非线性<br/>
    5. 度约束最小树问题（DCMSTP）：最小生成树问题（不懂）<br/>
上述典型问题及等价问题，普遍认为没有多项式算法求解</p>

<p>1.2 来自自然界的几类优化方法<br/>
计算智能系统是在神经网络、模糊系统、进化计算</p>

<ol>
<li>遗传算法的基本步骤（GA）：
<ol>
<li>问题的染色体表示</li>
<li>初始解组（种群）的生成</li>
<li>计算解组中各个解的适值函数（代价函数）</li>
<li>从解组中随机抽取两个解作为父母代</li>
<li>对父母代实施遗传操作（交叉、变异等）以产生一个后代解</li>
<li>按某种规则，用该后代解替换原解组中的某个解</li>
<li>按当前解组符合停机条件则算法终止，否则，转步骤1<br/>
结果的好坏主要依赖于遗传代数和解组规模<br/></li>
</ol></li>
<li>模拟退火算法基本步骤（SA）：<br/>
物体内部服从Boltzman分布
<ol>
<li>选择初始状态H（初始解）、初始温度、降温次数等</li>
<li>生成H的领域状态H‘，并计算两种状态下的目标函数f(H&#39;)-f(H)</li>
<li>按接受概率置换H为H‘</li>
<li>重复步骤2和步骤3直至停机条件满足</li>
</ol></li>
<li>禁忌搜索法（TS）在搜索过程中使用记忆功能</li>
<li>人工神经网络</li>
<li>蚁群系统：信息激素，轨迹，自催化行为，增强型学习系统</li>
<li>微粒群算法（PSO）：
<ol>
<li>依照初始化过程，对微粒群的随机位置和速度进行初始设定</li>
<li>计算每个微粒的适应值</li>
<li>对每个微粒，将其适应值与所经历过的最好位置进行比较，若较好，则将其作为当前的最好位置</li>
<li>对每个微粒，将其适应值与全局所经历的最好位置的适应值进行比较，若较好，则将其作为当前的的全局最好位置</li>
<li>对微粒的速度和位置进行进化</li>
<li>若未到达结束条件（通常为足够好的适应值或最大代数），则返回步骤2</li>
</ol></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数值分析]]></title>
    <link href="https://cubetian.github.io/15679868479784.html"/>
    <updated>2019-09-09T07:54:07+08:00</updated>
    <id>https://cubetian.github.io/15679868479784.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">灵敏度分析和误差分析</h2>

<h3 id="toc_1">灵敏度分析</h3>

<p><strong>敏感度分析</strong>（Sensitivity analysis）是研究数学模型或系统(数值或其他)输出中的不确定性如何在其输入中被分配到不同的不确定性来源。<a href="https://zh.wikipedia.org/wiki/%E6%95%8F%E6%84%9F%E5%BA%A6%E5%88%86%E6%9E%90#cite_note-1">[1]</a><a href="https://zh.wikipedia.org/wiki/%E6%95%8F%E6%84%9F%E5%BA%A6%E5%88%86%E6%9E%90#cite_note-2">[2]</a>一个相关的实践是不确定度分析，它更注重不确定度的量化和不确定度的传播;理想情况下，不确定度和灵敏度分析应该同时进行。</p>

<p>在其他假设下重新计算结果以确定变量在敏感性分析下的影响的过程可用于一系列目的，<a href="https://zh.wikipedia.org/wiki/%E6%95%8F%E6%84%9F%E5%BA%A6%E5%88%86%E6%9E%90#cite_note-3">[3]</a>包括：</p>

<ul>
<li>在存在不确定性的情况下测试模型或系统结果的稳健性。</li>
<li>增加对系统或模型中输入和输出变量之间关系的理解。</li>
<li>通过识别导致输出中存在显着不确定性的模型输入来减少不确定性，因此应该成为关注的焦点，以便提高稳健性（可能通过进一步的研究）。</li>
<li>搜索模型中的错误（通过遇到输入和输出之间的意外关系）。</li>
<li>模型简化 - 修复对输出没有影响的模型输入，或识别和删除模型结构的冗余部分。</li>
<li>加强建模人员与决策者之间的沟通（例如，通过提出更可信，可理解，引人注目或具有说服力的建议）。</li>
<li>在输入因子空间中查找模型输出为最大值或最小值或满足某个最佳标准的区域。</li>
<li>在校准具有大量参数的模型的情况下，主要灵敏度测试可以通过关注敏感参数来简化校准阶段。不知道参数的敏感性会导致无用的时间花在非敏感的时间上。<a href="https://zh.wikipedia.org/wiki/%E6%95%8F%E6%84%9F%E5%BA%A6%E5%88%86%E6%9E%90#cite_note-4">[4]</a></li>
<li>寻求识别观测，模型输入和预测或预测之间的重要联系，从而开发出更好的模型。<a href="https://zh.wikipedia.org/wiki/%E6%95%8F%E6%84%9F%E5%BA%A6%E5%88%86%E6%9E%90#cite_note-5">[5]</a><a href="https://zh.wikipedia.org/wiki/%E6%95%8F%E6%84%9F%E5%BA%A6%E5%88%86%E6%9E%90#cite_note-6">[6]</a></li>
</ul>

<p>（from wiki）</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[手表使用评价]]></title>
    <link href="https://cubetian.github.io/15681170584422.html"/>
    <updated>2019-09-10T20:04:18+08:00</updated>
    <id>https://cubetian.github.io/15681170584422.html</id>
    <content type="html"><![CDATA[
<p>最初在b站看到有关pebble的视频后，非常希望有这样一款造型简单，续航之间长，有时间和小题提醒功能就够了的手表，非常遗憾的是，pebble在中国境内不能给顺畅的使用，且有许多问题，不建议中国用户购买。<br/>
在淘宝搜寻过后，锁定在一款vla腕表，设计符合我的要求，价格便宜，且兼容ios。<br/>
毕竟是学生，在一番挣扎之后还是买了最便宜的cityA款，售价199，一般会有10元的优惠券。<br/>
约3天后收到手表，总体感觉不错，玻璃屏幕的硬度和清晰度都不错，蓝牙连接顺畅，且没有发现会影响手机的用电，手表电量充足，大约可以一个月充一次。<br/>
消息提醒功能暂时微信是完全正常的，qq最新版本存在问题，我非常高兴的是，手表的测试和开发人员都非常的积极，在与他们的一番讨论后，锁定了问题。非常难得的，购买了一款产品后可以联系到开发人员，这样的售后保障我想即使出现了问题也能很快进行修复。<br/>
总结一下，我觉得不亏</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[雅思阅读]]></title>
    <link href="https://cubetian.github.io/15680029212149.html"/>
    <updated>2019-09-09T12:22:01+08:00</updated>
    <id>https://cubetian.github.io/15680029212149.html</id>
    <content type="html"><![CDATA[
<p>雅思阅读开始可以分题型练习<br/>
题型主要有填空题、判断题、选择题、匹配题<br/>
填空题分为给选项的和不给选项的，不给选项的题型较容易，优先做，一般题目会涉及一大段或连续的几小段，填空一定填原词，甚至不需要修改形式，“”内的内容很有可能就是要填的<br/>
给选项的比较难，很有可能是无序的，除了根据词性排除一些内容，剩下的只能硬上了，可以放后面做</p>

<p>每道题基本上会对应一个段落或几个段落，出过题的段落不会再出，文意匹配除外</p>

<p>是非判断 true/false/not given  yes/no/not given<br/>
非与not given 的区别<br/>
非是文章给的情况和题目给的情况不能共存<br/>
not given 可以共存<br/>
我理解是 非是认知错误 not given是对象错误<br/>
事情的主语、宾语错误都是not given<br/>
然后如果至少有四个题那么 三种肯定都有 只有三个题，可能缺少一种选项</p>

<p>小匹配（在文章后的），只要一段里有提到就选那一段，不需要整段都是叙述这件事</p>

<p>大匹配（文章前） 最后做.. 很耗时间</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sklearn 模块参考书]]></title>
    <link href="https://cubetian.github.io/15679981303848.html"/>
    <updated>2019-09-09T11:02:10+08:00</updated>
    <id>https://cubetian.github.io/15679981303848.html</id>
    <content type="html"><![CDATA[
<p>sklearn 全称 scikit learn 是机器学习领域当中最知名的python模块之一</p>

<p>sklearn 包含了很多种机器学习的方式：</p>

<ul>
<li>Classification 分类</li>
<li>Regression 回归</li>
<li>Clustering 非监督分类</li>
<li>Dimensionality reduction 数据降维</li>
<li>Model Selection 模型选择</li>
<li>Preprocessing 数据预处理</li>
</ul>

<h2 id="toc_0">选择模型</h2>

<p>sklearn 中包含了众多的学习模型，我们需要根据实际问题选择适合的模型<br/>
这里有一张官网流程图帮助大家，根据实际问题，选择合适的模型<br/>
<img src="media/15679981303848/15679984183443.jpg" alt=""/></p>

<p>这里，本人还未完全熟悉所有学习方式，拷贝了sam‘s note 的相关链接</p>

<ul>
<li>2017/06/11   <a href="https://qinqianshan.com/machine_learning/sklearn/meachine-learning1-description/">【1】简介--1--机器学习</a></li>
<li>2017/06/11   <a href="https://qinqianshan.com/machine_learning/sklearn/meachine-learning2-sklearn/">【1】简介--2--sklearn简介</a></li>
<li>2018/08/14   <a href="https://qinqianshan.com/machine_learning/sklearn/supervised-learning/">【2】监督学习</a></li>
<li>2017/06/14   <a href="https://qinqianshan.com/machine_learning/sklearn/supervised-learning-classify/">【2】监督学习--1--分类</a></li>
<li>2018/08/28   <a href="https://qinqianshan.com/machine_learning/sklearn/sklearn-knn/">【2】监督学习--1--分类-K近邻分类器</a></li>
<li>2018/08/28   <a href="https://qinqianshan.com/machine_learning/sklearn/sklearn-decisiontree/">【2】监督学习--1--分类-决策树(DecisionTreeClassifier)</a></li>
<li>2018/08/28   <a href="https://qinqianshan.com/machine_learning/sklearn/sklearn-naivebayes/">【2】监督学习--1--分类-贝叶斯(naive_bayes)</a></li>
<li>2018/08/28   <a href="https://qinqianshan.com/machine_learning/sklearn/sklearn-naivebayes/">【2】监督学习--1--分类-支持向量机(svm)</a></li>
<li>2017/06/15   <a href="https://qinqianshan.com/machine_learning/sklearn/supervised-learning-logistic/">【2】监督学习--2--回归</a></li>
<li>2018/08/22   <a href="https://qinqianshan.com/machine_learning/sklearn/sklearn-polynomialfeatures/">【2】监督学习--3--多项式变形--PolynomialFeatures</a></li>
<li>2017/06/11   <a href="https://qinqianshan.com/machine_learning/sklearn/unsupervised-learning-cluster/">【3】无监督学习概述</a></li>
<li>2017/07/08   <a href="https://qinqianshan.com/machine_learning/sklearn/clustering-introduction/">【3】无监督学习--3--聚类--概述</a></li>
<li>2018/07/05   <a href="https://qinqianshan.com/machine_learning/sklearn/cluster-kmeans/">【3】无监督学习--3--聚类--基于距离--kmeans</a></li>
<li>2017/07/08   <a href="https://qinqianshan.com/machine_learning/sklearn/hierarchical-clustering/">【3】无监督学习--3--聚类--层次聚类</a></li>
<li>2018/05/16   <a href="https://qinqianshan.com/machine_learning/sklearn/cross-validation/">【4.1.1】模型选择与评估--1--交叉检验（Cross Validation）</a></li>
<li>2018/08/17   <a href="https://qinqianshan.com/machine_learning/sklearn/quantifying-the-quality-of-predictions/">【4.3.1】量化预测结果</a></li>
<li>2018/09/21   <a href="https://qinqianshan.com/machine_learning/sklearn/precision-recall-f-measure/">【4.3.2.3】量化预测结果--分类变量--准确率，召回和F-措施</a></li>
<li>2018/09/21   <a href="https://qinqianshan.com/machine_learning/sklearn/classification-metrics/">【4.3.2.1】量化预测结果--分类变量</a></li>
<li>2018/07/05   <a href="https://qinqianshan.com/machine_learning/sklearn/clustering-performance-evaluation/">【4.3.2.9】量化预测结果--分类变量--MCC、RI</a></li>
<li>2017/02/07   <a href="https://qinqianshan.com/machine_learning/sklearn/roc-curve-and-auc-evaluation-index/">【4.3.2.2】量化预测结果--分类变量--ROC曲线和AUC评价指标</a></li>
<li>2018/08/17   <a href="https://qinqianshan.com/machine_learning/sklearn/model-persistence/">【4.4.1】模型的保存与调用</a></li>
<li>2018/08/17   <a href="https://qinqianshan.com/machine_learning/sklearn/underfitting-overfitting/">【4.5.1】验证曲线--欠拟合和过拟合</a></li>
<li>2018/08/17   <a href="https://qinqianshan.com/machine_learning/sklearn/plotting-validation-curves/">【4.5.2】验证曲线--绘制验证曲线</a></li>
<li>2018/08/17   <a href="https://qinqianshan.com/machine_learning/sklearn/plotting-learning-curves/">【4.5.3】验证曲线--绘制学习曲线</a></li>
<li>2018/05/13   <a href="https://qinqianshan.com/machine_learning/sklearn/one-hot-encoding-in-scikit-learn/">【5】数据集转化--3--预处理数据-One Hot Encoding in Scikit-Learn</a></li>
<li>2017/07/07   <a href="https://qinqianshan.com/machine_learning/sklearn/1-plotting-cross-validated-predictions/">【9】例子--1--general--Plotting Cross-Validated Predictions（交叉验证预测）</a></li>
<li>2017/07/08   <a href="https://qinqianshan.com/machine_learning/sklearn/concatenating-multiple-feature-extraction-methods/">【9】例子--1--general--混合多重方法获得feature</a></li>
<li>2017/07/08   <a href="https://qinqianshan.com/machine_learning/sklearn/chaining-pca-and-logistic-regression/">【9】例子--1--general--PCA与逻辑回归的搭配</a></li>
<li>2017/07/07   <a href="https://qinqianshan.com/machine_learning/sklearn/isotonic-regression/">【9】例子--1--general--保序回归(Isotonic Regression)</a></li>
<li>2017/07/07   <a href="https://qinqianshan.com/machine_learning/sklearn/mac_sklearn_matplotlib/">【10】报错-1-Mac运行sklearn的matplotlib问题</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[wifi 相关]]></title>
    <link href="https://cubetian.github.io/15375337935500.html"/>
    <updated>2018-09-21T20:43:13+08:00</updated>
    <id>https://cubetian.github.io/15375337935500.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">使用大功率无线网卡抓取cap包用于密码破解（macos）</h2>

<p>1、安装aircrack-ng</p>

<p>命令：brew install aircrack-ng</p>

<p>注意，如果没安装brew,访问：<a href="https://brew.sh%EF%BC%8C%E9%A6%96%E9%A1%B5%E4%B8%8A%E6%9C%89%E5%AE%89%E8%A3%85brew%E7%9A%84%E5%91%BD%E4%BB%A4%EF%BC%8C%E6%88%91%E5%AE%89%E8%A3%85%E6%97%B6%EF%BC%88201706%EF%BC%89%E5%91%BD%E4%BB%A4%E5%A6%82%E4%B8%8B%EF%BC%9A">https://brew.sh，首页上有安装brew的命令，我安装时（201706）命令如下：</a></p>

<p>/usr/bin/ruby -e &quot;$(curl -fsSLhttps://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</p>

<p>2、添加airport快链</p>

<p>命令：ln -s /System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport /usr/local/bin/airport</p>

<p>3、使用mac自带的airport选取mac地址</p>

<p>命令：airport -s</p>

<p>选择CHANNEL的数值，比如：11</p>

<p>4、监听选定的频道获取到握手的包</p>

<p>命令：airport en0 sniff 11</p>

<p>运行一段时间，就可以在/tmp收获以.cap结尾的分析包，结束之后会提示保存的.cap文件位置</p>

<p>注意：（1）尽可能不要运行太长时间，否则.cap文件会比较大；</p>

<p>（2）可以使用ctr+c结束运行(我刚开始就不知道🙈)；</p>

<p>（3）如果提示权限问题，则使用 sudo airport en0 sniff 11</p>

<p>5、用 aircrack-ng分析cap包</p>

<p>命令：sudo aircrack-ng  /tmp/airportSniff******.cap</p>

<p>找到有(1 handshake)的那一行记录，记录下BSSID（比如是:10:02:22:23:7v:6f）。</p>

<p>建议直接搜索，否则能看晕，如果没有搜索到，请重新执行第4步；</p>

<p>6、开始暴力破解</p>

<p>命令：sudo aircrack-ng-wpojie.txt-b10:02:22:23:7v:6f/tmp/airportSniff******.cap</p>

<p>注意：.txt为破解字典</p>

<p>如果有碰撞到密码，程序会停止，并显示密码。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[scipy 模块参考书]]></title>
    <link href="https://cubetian.github.io/15679893433260.html"/>
    <updated>2019-09-09T08:35:43+08:00</updated>
    <id>https://cubetian.github.io/15679893433260.html</id>
    <content type="html"><![CDATA[
<p><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/index.html">SciPy Tutorial</a></p>

<ul>
<li><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/general.html">Introduction</a></li>
<li><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/basic.html">Basic functions</a></li>
<li><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/special.html">Special functions(scipy.special)</a></li>
<li><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/integrate.html">Integration(scipy.integrate)</a></li>
<li><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/optimize.html">Optimization(scipy.optimize)</a></li>
<li><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/interpolate.html">Interpolation(scipy.interpolate)</a></li>
<li><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/fftpack.html">Fourier Transforms(scipy.fftpack)</a></li>
<li><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/signal.html">Signal Processing(scipy.signal)</a></li>
<li><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/linalg.html">Linear Algebra(scipy.linagle)</a></li>
<li><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/arpack.html">Sparse Eigenvalue Problems with ARPACK</a></li>
<li><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/csgraph.html">Compressed Sparse Graph Routines(scipy.sparse.csgraph)</a></li>
<li><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/spatial.html">Spatial data structures and algorithms(scipy.spatial)</a></li>
<li><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/stats.html">Statistics(scipy.stats)</a></li>
<li><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/ndimage.html">Multidimensional image processing(scipy.ndimage)</a></li>
<li><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/io.html">File IO(scipy.io)</a></li>
</ul>

<pre><code class="language-text">import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
</code></pre>

<p>scipy 主要有15个子模块</p>

<pre><code class="language-text">from scipy import cluster, constants, fftpack, integrate, interpolate, io, linalg, ndimage, odr, optimize, signal, sparse, spatial, special, stats
</code></pre>

<hr/>

<h2 id="toc_0">常量 <a href="https://docs.scipy.org/doc/scipy/reference/constants.html#module-scipy.constants">Constants(scipy.constants)</a></h2>

<p>主要包含数学常数\(\pi\)(pi)以及一些物理常数 </p>

<hr/>

<h2 id="toc_1">基本函数</h2>

<h3 id="toc_2">np.r_ np.c_ 拼接</h3>

<pre><code class="language-text">&gt;&gt;&gt; np.r_[3,[0]*5,-1:1:10j]
array([ 3.        ,  0.        ,  0.        ,  0.        ,  0.        ,
        0.        , -1.        , -0.77777778, -0.55555556, -0.33333333,
       -0.11111111,  0.11111111,  0.33333333,  0.55555556,  0.77777778,
        1.        ])
</code></pre>

<p>将切片对象转换为沿第一轴的连接。(横向拼接)</p>

<pre><code class="language-text">&gt;&gt;&gt; np.c_[np.array([1,2,3]), np.array([4,5,6])]
array([[1, 4],
       [2, 5],
       [3, 6]])
</code></pre>

<p>将切片对象转换为沿第二轴的连接。(竖向拼接)<br/>
复数10j作为切片语​​法中的步长。这种非标准用法允许将数字解释为在范围内产生的点数而不是步长</p>

<h3 id="toc_3">np.mgrid 网格生成</h3>

<pre><code class="language-text">&gt;&gt;&gt; np.mgrid[0:5:4j,0:5:4j]
array([[[ 0.    ,  0.    ,  0.    ,  0.    ],
        [ 1.6667,  1.6667,  1.6667,  1.6667],
        [ 3.3333,  3.3333,  3.3333,  3.3333],
        [ 5.    ,  5.    ,  5.    ,  5.    ]],
       [[ 0.    ,  1.6667,  3.3333,  5.    ],
        [ 0.    ,  1.6667,  3.3333,  5.    ],
        [ 0.    ,  1.6667,  3.3333,  5.    ],
        [ 0.    ,  1.6667,  3.3333,  5.    ]]])
</code></pre>

<h2 id="toc_4">积分 (scipy.integrate)</h2>

<p>此模块可用用于各种包括反常积分在内的定积分的求解<br/>
\(I(a, b)=\int_{0}^{1} a x^{2}+b d x\)</p>

<pre><code class="language-text">&gt;&gt;&gt; from scipy.integrate import quad
&gt;&gt;&gt; def integrand(x, a, b):
...     return a*x**2 + b
...
&gt;&gt;&gt; a = 2
&gt;&gt;&gt; b = 1
&gt;&gt;&gt; I = quad(integrand, 0, 1, args=(a,b))
&gt;&gt;&gt; I
(1.6666666666666667, 1.8503717077085944e-14)
</code></pre>

<hr/>

<p>常微分方程求解 scipy.integrate.ode<br/>
BerkeleyMadonna 推荐使用，常微分方程求解器</p>

<h2 id="toc_5">线性代数相关</h2>

<pre><code class="language-text">from scipy import linalg
</code></pre>

<h3 id="toc_6">范数</h3>

<p>向量的范数<br/>
\(\|\mathbf{x}\|=\left\{\begin{array}{cl}{\max \left|x_{i}\right|} &amp; {\text { ord }=\inf } \\ {\min \left|x_{i}\right|} &amp; {\text { ord }=-\inf } \\ {\left(\sum_{i}\left|x_{i}\right|^{\text {ord }}\right)^{1 / \operatorname{ord}}} &amp; { | \text { ord } |&lt;\infty}\end{array}\right.\)<br/>
矩阵的范数<br/>
\(\|\mathbf{A}\|=\left\{\begin{aligned} \max _{i} \sum_{j}\left|a_{i j}\right| &amp; \text { ord }=\text { inf } \\ \min _{i} \sum_{j}\left|a_{i j}\right| &amp; \text { ord }=-\inf \\ \max _{j} \sum_{i}\left|a_{i j}\right| &amp; \text { ord }=1 \\ \min _{j} \sum_{i}\left|a_{i j}\right| &amp; \text { ord }=-1 \\ \max \sigma_{i} &amp; \text { ord }=2 \\ \min \sigma_{i} &amp; \text { ord }=-2 \\ \sqrt{\operatorname{trace}\left(\mathbf{A}^{H} \mathbf{A}\right)} &amp; \text { ord }=\text { &#39;fro }^{\prime} \end{aligned}\right.\)<br/>
例：</p>

<pre><code class="language-text">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import linalg
&gt;&gt;&gt; A=np.array([[1,2],[3,4]])
&gt;&gt;&gt; A
array([[1, 2],
      [3, 4]])
&gt;&gt;&gt; linalg.norm(A)
5.4772255750516612
&gt;&gt;&gt; linalg.norm(A,&#39;fro&#39;) # frobenius norm is the default
5.4772255750516612
&gt;&gt;&gt; linalg.norm(A,1) # L1 norm (max column sum)
6
&gt;&gt;&gt; linalg.norm(A,-1)
4
&gt;&gt;&gt; linalg.norm(A,np.inf) # L inf norm (max row sum)
7
</code></pre>

<h3 id="toc_7">特征值与特征向量</h3>

<pre><code class="language-text">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import linalg
&gt;&gt;&gt; A = np.array([[1, 2], [3, 4]])
&gt;&gt;&gt; la, v = linalg.eig(A)
&gt;&gt;&gt; l1, l2 = la
&gt;&gt;&gt; print(l1, l2)   # eigenvalues
(-0.3722813232690143+0j) (5.372281323269014+0j)
&gt;&gt;&gt; print(v[:, 0])   # first eigenvector
[-0.82456484  0.56576746]
&gt;&gt;&gt; print(v[:, 1])   # second eigenvector
[-0.41597356 -0.90937671]
</code></pre>

<h3 id="toc_8">LU分解</h3>

<p>\(A=PLU\)</p>

<pre><code class="language-text">&gt;&gt;&gt; from scipy.linalg import lu
&gt;&gt;&gt; A = np.array([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]])
&gt;&gt;&gt; p, l, u = lu(A)
</code></pre>

<h3 id="toc_9">追赶法</h3>

<p>\(a_{i} x_{i-1}+b_{i} x_{i}+c_{i} x_{i+1}=d_{i}\)<br/>
where \(a_{1}=0\) and \(c_{n}=0\)<br/>
\(\left[\begin{array}{ccccc}{b_{1}} &amp; {c_{1}} &amp; {} &amp; {} &amp; {0} \\ {a_{2}} &amp; {b_{2}} &amp; {c_{2}} &amp; {} &amp; {} \\ {} &amp; {a_{3}} &amp; {b_{3}} &amp; {\ddots} &amp; {} \\ {} &amp; {} &amp; {\ddots} &amp; {\ddots} &amp; {c_{n-1}} \\ {0} &amp; {} &amp; {} &amp; {a_{n}} &amp; {b_{n}}\end{array}\right]\left[\begin{array}{c}{x_{1}} \\ {x_{2}} \\ {x_{3}} \\ {\vdots} \\ {x_{n}}\end{array}\right]=\left[\begin{array}{c}{d_{1}} \\ {d_{2}} \\ {d_{3}} \\ {\vdots} \\ {d_{n}}\end{array}\right]\)</p>

<pre><code class="language-text">import numpy as np

## Tri Diagonal Matrix Algorithm(a.k.a Thomas algorithm) solver
def TDMAsolver(a, b, c, d):
    &#39;&#39;&#39;
    TDMA solver, a b c d can be NumPy array type or Python list type.
    refer to http://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm
    and to http://www.cfd-online.com/Wiki/Tridiagonal_matrix_algorithm_-_TDMA_(Thomas_algorithm)
    &#39;&#39;&#39;
    nf = len(d) # number of equations
    ac, bc, cc, dc = map(np.array, (a, b, c, d)) # copy arrays
    for it in range(1, nf):
        mc = ac[it-1]/bc[it-1]
        bc[it] = bc[it] - mc*cc[it-1] 
        dc[it] = dc[it] - mc*dc[it-1]
                
    xc = bc
    xc[-1] = dc[-1]/bc[-1]

    for il in range(nf-2, -1, -1):
        xc[il] = (dc[il]-cc[il]*xc[il+1])/bc[il]

    return xc
</code></pre>

<p>例：</p>

<pre><code class="language-text">A = np.array([[10,2,0,0],[3,10,4,0],[0,1,7,5],[0,0,3,4]],dtype=float)   

a = np.array([3.,1,3]) 
b = np.array([10.,10.,7.,4.])
c = np.array([2.,4.,5.])
d = np.array([3,4,5,6.])

print(TDMAsolver(a, b, c, d))
&gt;&gt; [ 0.14877589  0.75612053 -1.00188324  2.25141243]
#compare against numpy linear algebra library
print(np.linalg.solve(A, d))
&gt;&gt; [ 0.14877589  0.75612053 -1.00188324  2.25141243]
</code></pre>

<h3 id="toc_10">对角线元素</h3>

<pre><code class="language-text">numpy.diag(v,k=0)
</code></pre>

<p>如果v是一个二维的矩阵，则返回对角线元素组成的向量<br/>
如果v是一个一维的向量，则返回对角线为该向量的矩阵<br/>
k表示偏移量，正数为右移，负数为左移</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[爬虫学习]]></title>
    <link href="https://cubetian.github.io/15678538813115.html"/>
    <updated>2019-09-07T18:58:01+08:00</updated>
    <id>https://cubetian.github.io/15678538813115.html</id>
    <content type="html"><![CDATA[
<p>r = request.get(url)</p>

<p>r (response)的五个属性<br/>
status_code 200表示成功，404表示失败<br/>
text 响应内容的字符串形式，即，url对应的网页内容<br/>
encoding 内容编码方式<br/>
apparent_encoding 备选编码方式</p>

<p>如果header中不存在charset，则认为编码为ISO-8859-1但不能解析中文<br/>
content 二进制编码内容</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[合同]]></title>
    <link href="https://cubetian.github.io/15675882890776.html"/>
    <updated>2019-09-04T17:11:29+08:00</updated>
    <id>https://cubetian.github.io/15675882890776.html</id>
    <content type="html"><![CDATA[
<p>\(ax^2+2bxy+cy^2=d\)<br/>
\(x=x&#39;cos\the - y&#39;sin\)<br/>
\(y=x&#39;sin + y&#39;\)</p>

]]></content>
  </entry>
  
</feed>
